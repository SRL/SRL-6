(*
Text
====

The text file holds functions and procedures that are used in Runescape text
recognition.

The source for this file can be found `here <https://github.com/SRL/SRL-6/blob/master/lib/core/text.simba>`_.

*)

{$include_once debug.simba}
{$include_once mouse.simba}

{$f-}

(*
findText
~~~~~~~~

.. code-block:: pascal

    function findText(var p: TPoint; txt, fonts: TStringArray; searchBox: TBox): boolean;

Uses a bitmap mask to find text on the screen.  Returns true if the text is found.

    * p: The point the text is found.
    * txt: The text to look for.
    * fonts: The font(s) of the text.
    * searchBox: The box to look for the text.

.. note::

    - by Stupid3ooo, modified by LordJashin & Coh3n
    - Last Updated: Feb. 20, 2013 by Coh3n

Example:

.. code-block:: pascal

    var
      p: TPoint;
    begin
      if (findText(p, ['Lobby'], [upCharsEx], tabLogout.bounds)) then
        writeln('Found "Exit to Lobby" text');
      .
      .
      .
    end;
*)
function findText(var p: TPoint; txt, fonts: TStringArray; searchBox: TBox): boolean;
var
  s, i, j, w, h: integer;
begin
  p := point(-1, -1);

  for i := 0 to high(txt) do
    for j := 0 to high(fonts) do
    begin
      s := bitmapFromText(toStr(txt[i]), toStr(fonts[j]));

      // to prevent looking outside the client
      if (searchBox.x1 < 0) then searchBox.x1 := 0;
      if (searchBox.y1 < 0) then searchBox.y1 := 0;

      if (findBitmapMaskTolerance(s, p, searchBox, 30, 30)) then
      begin
        getBitmapSize(s, w, h);
        p := point(p.x + round(w / 2), p.y + round(h / 2));
        result := true;
      end;

      freeBitmap(s);

      if (result) then
        break(2);
    end;
end;

(*
findText; overload;
~~~~~~~~~~~~~~~~~~~

.. code-block:: pascal

    function findText(var p: TPoint; col, tol: integer; txt, fonts: TStringArray; lookIn: TBox; waitTime: integer = 0): boolean; overload;

Uses TPointArrays to find text on the screen.  Searches for the color (col) with
tolerance (tol) on the screen, then looks for the text (txt) in a TPA created
from the fonts (fonts).  Looks in the box (lookIn) and returns the point found
(p). Returns true if the text is found. If the optional parameter (waitTime) is
set, will wait specified amount of time for the text to be found before returning
false.


.. note::

    - by Raymond and Coh3n
    - Last Updated: Feb. 20, 2013 by Coh3n

Example:

.. code-block:: pascal

    var
      p: TPoint;
    begin
      if (findText(p, clWhite, 10, ['Lobby'], [upCharsEx], gameTabArea)) then
        writeln('Found "Exit to Lobby" text');
      .
      .
      .
    end;
*)
function findText(var p: TPoint; col, tol: integer; txt, fonts: TStringArray; lookIn: TBox; waitTime: integer = 0): boolean; overload;
var
  b: TBox;
  i, j, w, h, t: integer;
  tpaColors, tpaText, matches: TPointArray;
begin
  t := (getSystemTime() + waitTime);
  p := point(-1, -1);

  if (not findColorsTolerance(tpaColors, col, lookIn, tol)) then
  begin
    print('findText: failed to find text color', TDebug.SUB);
    exit(false);
  end;

  repeat
    // loop through the fonts and texts to look for
    for i := 0 to high(txt) do
      for j := 0 to high(fonts) do
      begin
        tpaText := TPAFromText(txt[i], fonts[i], w, h);

        if (tpaColors.findTextIn(h - 1, tpaText, matches)) then
        begin
          // sort the tpa matches and return the top left of the text
          b := tpaText.getBounds();
          matches.sortFromPoint(point(b.x1, b.y1));
          p := matches[0];

          result := true;
          break(3);
        end;
      end;

  until(getSystemTime() > t);

  if (not result) then
    print('findTextByColor('+toStr(txt)+'): '+toStr(result), TDebug.SUB);
end;

(*
mouseText
~~~~~~~~~

.. code-block:: pascal

    function mouseText(txt, fonts: TStringArray; searchBox: TBox; mouseAction: integer): boolean;

Returns true if the mouse action is performed on the text.

    * txt: The text to look for.
    * fonts: The font(s) of the text.
    * searchBox: The box to look for the text.
    * mouseAction: The action of the mouse.

.. note::

    - by Coh3n
    - Last Updated: Mar. 1, 2013 by Coh3n

Example:

.. code-block:: pascal

    mouseText(['Lobby'], [upCharsEx], tabLogout.bounds, MOUSE_LEFT);
*)
function mouseText(txt, fonts: TStringArray; searchBox: TBox; mouseAction: integer): boolean;
var
  p: TPoint;
begin
  if (findText(p, txt, fonts, searchBox)) then
  begin
    mouse(p.rand(3, 10), mouseAction);
    exit(true);
  end;
end;

(*
typeByte
~~~~~~~~

.. code-block:: pascal

    procedure typeByte(k: byte);

Types one character k.

.. note::

    - by Mutant Squirrle

Example:

.. code-block:: pascal

    typeByte(VK_ENTER);

*)
procedure typeByte(k: byte);
begin
  {$IFDEF SMART}
  if (k = 13) then
    k := 10;
  {$ENDIF}

  KeyDown(k);
  Wait(10 + Random(50));
  KeyUp(k);
end;

(*
typeSend
~~~~~~~~

.. code-block:: pascal

    procedure typeSend(text: string; pressEnter: boolean = true);

Types text in a human-like way.  Optional parameter 'pressEnter'.  Will press
enter by default.

.. note::

    - by SKy Scripter
    - Last Updated: January 29th, 2013 by Coh3n

Example:

.. code-block:: pascal

    // to type and press enter
    typeSend('Hello');

    // to type and not press enter
    typeSend('Hello', false);

*)
procedure typeSend(text: string; pressEnter: boolean = true);
var
  i: Integer;
begin
  for i := 1 to Length(Text) do
  begin
    SendKeys(Text[i], 30 + Random(30), 30 + Random(30));
    Wait(40 + Random(40));
  end;

  if (pressEnter) then
    TypeByte(VK_ENTER);
end;

{*
type __TOptions
~~~~~~~~~~~~~~~

Used to store an RS right click menu.
*}
type
  __TOptions = record
    str: string;
    bounds, bigBox: TBox;
  end;

{*
__debugOptions
~~~~~~~~~~~~~~

.. code-block:: pascal

    procedure __debugOptions(options: array of __TOptions);

Prints the options' .str attribute to the printToDebug box.

.. note::

    - by Coh3n
    - Last Updated: Feb. 27, 2013 by Coh3n

Example:

.. code-block:: pascal

    __debugOptions(options);
*}
procedure __debugOptions(options: array of __TOptions);
var
  i: integer;
begin
  print('Options found: ');

  for i := 0 to high(options) do
    print(options[i].str, TDebug.SUB);
end;

{*
__getChooseOptions
~~~~~~~~~~~~~~~~~~

.. code-block:: pascal

    function __getChooseOptions(excludeBox: TBox; tabbed: boolean = false): array of __TOptions;

Gets the text from the options menu. Searches for the menu in the entire client.

    * excludeBox: The box to exclude of colors are found. Only used when searching a tabbed menu.
    * tabbed: Optional. Default false. Set to true if looking for tabbed options.

.. note::

    - by Wizzup?, Narcle, Coh3n & Flight
    - Last Updated: 01 August 2013 by Coh3n

Example:

.. code-block:: pascal

    tabbedOptions := __getChooseOptions(MS_BOX, true);
*}
function __getChooseOptions(excludeBox: TBox; tabbed: boolean = false): array of __TOptions;
var
  b, bb, bigBox: TBox;
  TPA, TPA1, TPA2, tpaText, tpaNotText, tpaShadow, tpaFilter: TPointArray;
  ATPA, tmpATPA: T2DPointArray;
  i, l, bW, bH, bmp, oldTarget, oldCTS, t: integer;
  menuColors: TIntegerArray;
begin
  oldTarget := getImageTarget();

  // the entire RS client
  getClientDimensions(b.x2, b.y2);
  b := intToBox(0, 0, b.x2 - 1, b.y2 - 1);

  oldCTS := getToleranceSpeed();
  setColorToleranceSpeed(1);

  setLength(menuColors, 3);

  menuColors := [197636 {black}, 3748386 {top blue}, 3618615 {grey}];
  setLength(ATPA, length(menuColors));

  // find how many of each menu color is found; store in ATPA
  for i := 0 to high(menuColors) do
    findColors(ATPA[i], menuColors[i], b);

  TPA := ATPA.merge();

  if (length(tpa) < 1) then
  begin
    print('__getChooseOptions(): Failed to find any choose option box color', TDebug.SUB);
    setColorToleranceSpeed(oldCTS);
    exit();
  end;

  if (tabbed) then
  begin
    tpaFilter := TPA.clearTPAFrom(TPAFromBox(excludeBox));
    ATPA := splitTPAEx(tpaFilter, 4, 4);
  end else
    ATPA := splitTPAEx(TPA, 4, 4);

  // gets the right box of colors on the MS by checking the size of each color's area
  for i := 0 to high(ATPA) do
  begin
    b := ATPA[i].getBounds();

    if ((b.x2 - b.x1) > 90) and ((b.y2 - b.y1) > 18) then
      break;
  end;

  bigBox := b; // used in chooseOption to move the mouse away if the options don't exist
  setColorToleranceSpeed(3);

  // get TPAs of the text, around text, and shadow
  findColorsTolerance(tpaText, 4996381, b, 18);
  tpaNotText := tpaText.returnNotInTPA(tpaText.getBounds());
  findColorsTolerance(tpaShadow, 460291, b, 6);

  setColorToleranceSpeed(oldCTS);

  // create a bitmap of size b (the size of the menu)
  bmp := createBitmap(b.x2 - b.x1 + 2, b.y2 - b.y1 + 2);

  // "reset" not text/shadow TPAs so they can be drawn on bmp
  tpaNotText.offset(point(-b.x1, -b.y1));
  tpaShadow.offset(point(-b.x1, -b.y1));

  fastDrawClear(bmp, 0);
  drawTPABitmap(bmp, tpaNotText, clRed);
  drawTPABitmap(bmp, tpaShadow, clPurple);

  ocr_FilterUpTextByCharacteristics(getMufasaBitmap(bmp));
  getBitmapSize(bmp, bW, bH);

  setTargetBitmap(bmp); // new target for findColors
  setLength(ATPA, bH div 16);

  // look for the outlined text on the bitmap
  for i := 0 to high(ATPA) do
    findColors(ATPA[i], clRed, 0, (2 + i * 16), bW - 1, (18 + i * 16) - 1); // +2 to y to line it up

  l := high(ATPA);
  sortATPAFromFirstPointY(ATPA, point(bW div 2, 0));

  if (length(ATPA) < 1) then
  begin
    setImageTarget(oldTarget);
    freeBitmap(bmp);
    exit();
  end;

  setLength(result, length(ATPA));
  result[0].bigBox := bigBox;

  for i := 0 to l do
  begin
    tmpATPA := ATPA[i].split(1, 10); // split one into characters
    sortATPAFromFirstPointX(tmpATPA, point(0, 0));

    result[i].str := tmpATPA.getTextInATPA(5, 'UpCharsEx');
    //writeln(result[i].str);

    bb := ATPA[i].getBounds();
    result[i].bounds := intToBox((bb.x1 + b.x1), (bb.y1 + b.y1), (bb.x2 + b.x1), (bb.y2 + b.Y1));
  end;

  setColorToleranceSpeed(oldCTS);
  t := getImageTarget();

  setImageTarget(oldTarget);

  freeTarget(t);
  freeBitmap(bmp);
end;

(*
chooseOption
~~~~~~~~~~~~

.. code-block:: pascal

    function chooseOption(txt, txtTab: TStringArray; mouseAction: integer; close: boolean = true; waitTime: integer = 100): boolean;

Works for RS tabbed menus.

    * txtTab: The final option you want to choose. The function looks for this option first.
    * txt: The text that the mouse hovers to activate the tabbed menu.
    * mouseAction: What you want the mouse to do.  Mouse constants are in mouse.simba.
    * close: Optional; default true. Will move the mouse away from the menu if the option isn't found.
    * waitTime: Optional; default 100ms. The time you want the function to wait for the options to be found.

.. note::

    - by Wizzup?, Nava2 & N1ke!
    - Last Modified: 30 May 2013 by Coh3n

Example:

.. code-block:: pascal

    if (chooseOption(['Bank'], ['Use'], MOUSE_LEFT)) then
      writeln('Using bank');
*)
function chooseOption(txt, txtTab: TStringArray; mouseAction: integer; close: boolean = true; waitTime: integer = 100): boolean;
  // used to move the mouse away from the options menu if the option isn't found
  procedure __mouseAway(bigBox: TBox; mouseAction: integer; close: boolean);
  var
    j: integer;
  begin
    if (mouseAction <> MOUSE_NONE) and (close) then
    begin
      print('Closing the menu');

      j := max(bigBox.x1 - 52, 0);

      if (j = 0) then
        j := (bigBox.x2 + 10);

      mouse(point(j, max(bigBox.y1 - 50, 0)).rand(40, bigBox.y2 - bigBox.y1));
      wait(200 + random(100));
    end;
  end;
var
  b: TBox;
  p: TPoint;
  textFound: boolean;
  i, t: integer;
  options: array of __TOptions;
begin
  print('chooseOption()', TDebug.HEADER);

  result := false;
  wait(waitTime + random(50)); // an initial wait after mouse is clicked
  t := (getSystemTime() + waitTime);

  repeat
    options := __getChooseOptions(b);
    __debugOptions(options);

    // if using the tabbed option
    if (length(txtTab) > 0) then
    begin
      if (chooseOption(txtTab, TStringArray([]), MOUSE_LEFT, false, 0)) then // choose the final option if it exists
      begin
        print('chooseOption(): True', TDebug.FOOTER);
        exit(true);
      end else
        if (not chooseOption(txt, TStringArray([]), MOUSE_MOVE, false, 0)) then // move the mouse to the first option
        begin
          if (length(options) > 0) then
            __mouseAway(options[0].bigBox, mouseAction, close);

          print('Text '+toStr(txt)+' not found');
          print('chooseOption(): False', TDebug.FOOTER);
          exit(false);
        end;

      wait(100 + random(100));
      options := __getChooseOptions(options[0].bigBox, true);
    end;

    if (length(options) <= 0) then
    begin
      print('No options available');
      print('chooseOption(): False', TDebug.FOOTER);
      exit(false);
    end;

    for i := 0 to high(options) do
    begin
      if (length(txtTab) > 0) then
        textFound := isArrInStr(txtTab, options[i].str)
      else
        textFound := isArrInStr(txt, options[i].str);

      if (textFound) then
      begin
        // carefully move the mouse to the tabbed menu
        if (length(txtTab) > 0) then
        begin
          getMousePos(p.x, p.y);
          mouse(point(randomRange(options[0].bigBox.x1, options[0].bigBox.x2), p.y), MOUSE_MOVE, MOUSE_ACCURATE);
        end;

        mouseBox(options[i].bounds, mouseAction);
        print('Found option: '+ options[i].str);
        print('chooseOption(): True', TDebug.FOOTER);
        exit(true);
      end;
    end;

    wait(25 + random(25));
  until(getSystemTime() > t);

  // lets debug the options if we didnt find any match
  print('Didn''t find any matches');
  __debugOptions(options);

  if (length(options) > 0) then
    __mouseAway(options[0].bigBox, mouseAction, close);

  print('chooseOption(): '+toStr(result), TDebug.FOOTER);
end;

(*
chooseOption; overload;
~~~~~~~~~~~~~~~~~~~~~~~

.. code-block:: pascal

    function chooseOption(txt: TStringArray; waitTime: integer = 100): boolean; overload;

Chooses the first option in txt that's found in the RS right click menu. Will
left click the option if found. Will wait (waitTime) for the options to
exist. Default waitTime is 100ms.

.. note::

    - by Coh3n
    - Last Updated: May. 24, 2013 by Ollybest

Example:

.. code-block:: pascal

    if (chooseOption(['Examine'])) then
      writeln('Examining something...');
*)
function chooseOption(txt: TStringArray; waitTime: integer = 100): boolean; overload;
begin
  result := chooseOption(txt, TStringArray([]), MOUSE_LEFT, waitTime);
end;

(*
optionsExist
~~~~~~~~~~~~

.. code-block:: pascal

    function optionsExist(txt: TStringArray): boolean;

Returns true if one of the strings in txt exists in the options menu.

.. note::

    - by Coh3n
    - Last Modified: Mar. 10, 2013 by Coh3n

Example:

.. code-block:: pascal

    if (optionsExist(['Examine'])) then
      writeln('Option exists');
*)
function optionsExist(txt: TStringArray): boolean;
begin
  result := chooseOption(txt, TStringArray([]), MOUSE_NONE, 0);
end;

{*
__findMouseOverBox
~~~~~~~~~~~~~~~~~~

.. code-block:: pascal

    function __findMouseOverBox(out box: TBox): boolean;

Returns true if the mouse-over box is found on the client.  Returns it's coordinates
in 'box'.

.. note::

    - by euphemism
    - Last Modified: 12 August 2013 by euphemism

Example:

.. code-block:: pascal

    if (__findMouseOverBox(tmpBox)) then
      writeln('Found mouse-over box!');
*}
function __findMouseOverBox(out box: TBox): boolean;
var
  h, i, j, len, w, y2OfBounds: integer;
  tpa: TPointArray;
  atpa: T2DPointArray;
begin
  getClientDimensions(w, h);

  if (not (findColors(tpa, 11579568, 0, 0, w -1, h - 1))) then // Grey text box border
    exit(false);

  box := intToBox(-1, -1, -1, -1);

  atpa := splitTPAEx(tpa, 2, 2); // Group the points we found
  len := length(atpa);
  setLength(tpa, len); // Repurpose tpa variable to contain midpoints of the tpas stored in atpa

  for i := 0 to (len - 1) do // Get midpoint of each group
    tpa[i] := middleTPA(atpa[i]);

  for i := 0 to (len - 1) do // Compare each midpoints to every other midpoint
    for j := 0 to (len - 1) do
      if (tpa[i].y = tpa[j].y) then // If the y coordinates are the same, then the two midpoints are horizontally aligned
        if (not (tpa[i].x = tpa[j].x)) then // If the x coordinates are also the same, then we are comparing the same point and should continue the inner loop
        begin // Otherwise, we have two horizontally-aligned midpoints, which means they are most likely the left and right edges of the box
          y2OfBounds := getTPABounds(atpa[i]).y2 + 5; // Gets the y2 bound of our return box based on the bottom of one of the edge strips

          if (getColor(((tpa[i].x + tpa[j].x) div 2), y2OfBounds + 1)) then // If we get the edge color at the point halfway between the two lines we are testing, and down where the bottom edge should be
          begin // Then we have definitely found the box

            box.y2 := y2OfBounds; // Here, we set the y2 coordinate of our return box based on the y2 coordinate of the bottom pixel in the group that our midpoint is in
            break(2); // Break out of both loops
           end;
        end else
          continue;

  if (box.y2 = -1) then // If the y2 coordinate of our return box is still -1, we did not find any horizontally-aligned groups and should return false
    exit(false);

  if (tpa[i].x > tpa[j].x) then // If the first midpoint is actually further right than the second midpoint, we will swap the indexes so that we just need the code below, and not a duplicate set based on a condition
    swap(i, j);

  box.x1 := (tpa[i].x + 1); box.x2 := (tpa[j].x - 1); // The x1 coordinate of our return box is the x coordinate of our first midpoint + 1 to get just the black of the hover-text box and not the grey of the border, similar process for the x2 coordinate

  j := (tpa[i].y - (box.y2 - tpa[i].y)); // Difference between y coordinate of the midpoint of one of the edges and the y2 coordinate of the return box, this is then subracted from the y coordinate of the midpoint to get the y1 for our return box
  box.y1 := j;
  if (j < 0) then // If j is less than zero, then the box is running off the top of the screen and the y1 coordinate should be set to zero, otherwise there will be out-of-range errors
    box.y1 := 0

  if (getColor((box.x1 + box.x2) div 2, box.y1) = 11579568) then // The box is sometimes not perfectly symmetric with respect to being reflected around the horizontal line through the box
    inc(box.y1); // So occasionally we end up with the top 1px of the box, which includes the border, we don't want that

  result := true;
end;

{*
__createMouseOverFilter
~~~~~~~~~~~~~~~~~~~~~~~

.. code-block:: pascal

    procedure __createMouseOverFilter(box: TBox; var cleanBitmap, filteredBitmap: integer);

Creates a filtered bitmap to be used to read the mouse-over text.

.. note::

    - by euphemism
    - Last Modified: 12 August 2013 by euphemism

Example:

.. code-block:: pascal

    __createMouseOverFilter(tmpBox, bmpClean, bmpFiltered);
*}
procedure __createMouseOverFilter(box: TBox; var cleanBitmap, filteredBitmap: integer);
begin
  cleanBitmap := bitmapFromClient(box);
  filteredBitmap := copyBitmap(cleanBitmap);

  getMufasaBitmap(filteredBitmap).contrast(50);
  getMufasaBitmap(filteredBitmap).desaturate();
  getMufasaBitmap(filteredBitmap).contrast(255);
  getMufasaBitmap(filteredBitmap).posterize(255);
end;

{*
__getMouseOverText
~~~~~~~~~~~~~~~~~~

.. code-block:: pascal

    function __getMouseOverText(box: TBox; cleanBitmap, filteredBitmap: integer): string;

Returns the mouse-over text found inside the 'box' based on the clean and
filtered bitmaps.

.. note::

    - by euphemism
    - Last Modified: 12 August 2013 by euphemism

Example:

.. code-block:: pascal

    if (__findMouseOverBox(tmpBox)) then
    begin
      __createMouseOverFilter(tmpBox, bmpClean, bmpFiltered);
      text := __getMouseOverText(tmpBox, bmpClean, bmpFiltered);
      writeln('Mouse-over text: '+text);
    end;
*}
function __getMouseOverText(box: TBox; cleanBitmap, filteredBitmap: integer): string;
var
  numberOfLines, badCounter, colorCheck, i, j, len, w, h, startIndex: integer;
  font: string;
  p1, p2: TPoint;
  firstLineCharactersYCords: TIntegerArray;
  textColors: TIntegerArray;
  tpa, midPoints: TPointArray;
  atpa, tempATPA: T2DPointArray;
  linesOfText: array of T2DPointArray;
begin
  textColors := [
    4305653,      // Burnt Orange, thin text when you mouse over interface items.
    12378347,     // Beige, generic mouse-over text color.
    65535,        // Yellow NPC name when mousing over NPC.
    16776960,     // Cyan color of object name when mousing over an object.
    clWhite,      // White that shows up when numbers are displayed in the mouseover boxes that have burnt orange text.
    13750712,     // Grey-ish blue of inventory items.
    7067128,      // Gold of inventory items.
    4231423       // Orange of item name under equipment tab.
  ];

  getMufasaBitmap(filteredBitmap).findColors(tpa, clWhite);
  getBitmapSize(cleanBitmap, w, h);

  atpa := splitTPAEx(tpa, 1, 1);
  len := length(atpa);
  setLength(firstLineCharactersYCords, len);

  for i := 0 to (len - 1) do
    if (not textColors.isInArray(fastGetPixel(cleanBitmap, atpa[i][0].x, atpa[i][0].y))) then
    begin
      setLength(atpa[i], 0);
      inc(badCounter);
    end;

  sortATPASize(atpa, true);
  setLength(atpa, len - badCounter);

  len := length(atpa);
  setLength(midPoints, len);

  sortATPAFromFirstPointX(atpa, point(0, h div 2));

  for i := 0 to (len - 1) do
  begin
    p1 := atpa[i].getMiddle();

    if (numberOfLines <> 0) then
    begin
      for j := 0 to (numberOfLines - 1) do
      begin
        p2 := atpa[j].getMiddle();

        if (inRange(p1.y, p2.y - 4, p2.y + 4)) then
          break(2);
      end;

      firstLineCharactersYCords[numberOfLines] := p1.y;
      inc(numberOfLines);
    end else
    begin
      firstLineCharactersYCords[numberOfLines] := p1.y;
      inc(numberOfLines);
    end;
  end;

  setLength(linesOfText, numberOfLines);

  sortATPAFromFirstPointY(atpa, point(w div 2, 0));

  for i := 0 to (len - 1) do
    midPoints[i] := atpa[i].getMiddle();

  startIndex := 0;

  for i := 0 to (numberOfLines - 1) do
  begin
    setLength(linesOfText[i], len);

    for j := startIndex to (len - 1) do
    begin
      linesOfText[i][j - startIndex] := atpa[j];

      if (not inRange(midPoints[j].y, firstLineCharactersYCords[i] - 6, firstLineCharactersYCords[i] + 6)) then
      begin
        setLength(linesOfText[i], j - startIndex);
        startIndex := j;
        break;
      end;
    end;

    linesOfText[i] := splitTPAEx(mergeATPA(linesOfText[i]), 1, 3);
    sortATPAFromFirstPointX(linesOfText[i], point(0, h div 2));
  end;

  for i := 0 to (numberOfLines - 1) do
  begin
    colorCheck := fastGetPixel(cleanBitmap, linesOfText[i][0][0].x, linesOfText[i][0][0].y);

    if (not textColors.isInArray(colorCheck)) then
      continue;

    tempATPA := splitTPAEx(atpa[i], 1, 5);
    sortATPAFromFirstPointX(tempATPA, point(0, 0));

    case (colorCheck) of
      4305653, clWhite: font := 'SmallChars';
      12378347, 65535, 16776960, 4231423: font := 'UpCharsEx';
    else
      continue;
    end;

    if (i = 0) then
      result := result + linesOfText[i].getTextInATPA(3, font)
    else
      result := result + ' ' + linesOfText[i].getTextInATPA(3, font);
  end;
end;

(*
getMouseOverText
~~~~~~~~~~~~~~~~

.. code-block:: pascal

    function getMouseOverText(): string;

Returns the current mouse-over text.

.. note::

    - by euphemism & Coh3n
    - Last Modified: 12 August 2013 by Coh3n

Example:

.. code-block:: pascal

    writeln(getMouseOverText());
*)
function getMouseOverText(): string;
var
  box: TBox;
  bmpClean, bmpFiltered: integer;
begin
  result := '';

  if (__findMouseOverBox(box)) then
  begin
    __createMouseOverFilter(box, bmpClean, bmpFiltered);
    result := __getMouseOverText(box, bmpClean, bmpFiltered);

    freeBitmap(bmpClean);
    freeBitmap(bmpFiltered);
  end;
end;

(*
isMouseOverText
~~~~~~~~~~~~~~~

.. code-block:: pascal

    function isMouseOverText(txt: TStringArray; waitTime: integer = 100): boolean;

Returns true if one of the indexes in 'txt' is found in the current mouse-over text.
Will wait up to 'waitTime' to find the text before exiting the function.

.. note::

    - by Coh3n
    - Last Modified: 12 August 2013 by Coh3n

Example:

.. code-block:: pascal

    if (isMouseOverText(['Tree'])) then
    begin
      getMousePos(x, y);
      mouse(point(x, y), MOUSE_LEFT);
    end;
*)
function isMouseOverText(txt: TStringArray; waitTime: integer = 100): boolean;
var
  i, t: integer;
  s: string;
begin
  print('isMouseOverText()', TDebug.HEADER);
  t := (getSystemTime() + waitTime);

  repeat
    s := getMouseOverText();
    print('Current mouse-over text: "'+s+'"');

    for i := 0 to high(txt) do
      if (pos(txt[i], s) > 0) then
      begin
        print('Found "'+txt[i]+'" in mouse-over string: "'+s+'"');
        result := true;
        break(2);
      end;

    wait(10 + random(20));
  until (getSystemTime() > t);

  print('isMouseOverText(): '+toStr(result), TDebug.FOOTER);
end;

(*
isMouseOverMenuOpen
~~~~~~~~~~~~~~~~~~~

.. code-block:: pascal

    function isMouseOverMenuOpen(var res: TBox; waitTime: integer = 100): boolean;

Returns true if the mouse-over menu is open.  Will wait a maximum of
'waitTime' for the menu to appear.

.. note::

    - by Coh3n
    - Last Modified: 12 August 2013 by Coh3n

Example:

.. code-block:: pascal

    if (isMouseOverMenuOpen()) then
      writeln('Mouse-over menu is open');
*)
function isMouseOverMenuOpen(var res: TBox; waitTime: integer = 100): boolean;
var
  t: integer;
begin
  res := [-1, -1, -1, -1];
  t := (getSystemTime() + waitTime);

  while ((getSystemTime() < t) and (not result)) do
  begin
    result := __findMouseOverBox(res);
    wait(20 + random(20));
  end;
end;

