(*
Mouse
=====

The Mouse include contains all Mouse movement and clicking functions.

*)

{$include_once ../tmp.simba}

(*
var mouseSpeed
~~~~~~~~~~~~~~

Adjustable mouse speed variable. Default set to 20.
*)
var
  mouseSpeed: Integer = 20;

(*
const Mouse Styles
~~~~~~~~~~~~~~~~~~

Different ways of moving the mouse:
    * MOUSE_BREAK: moves slower when reaching destination.
    * MOUSE_ACCURATE: a slower, more accurate movement.
    * MOUSE_HUMAN: the most human-like movement of the mouse styles.
*)
const
  MOUSE_BREAK    = 8;
  MOUSE_ACCURATE = 14;
  MOUSE_HUMAN    = 7;

{*
_brakeWindMouse
~~~~~~~~~~~~~~~

.. code-block:: pascal

    procedure _brakeWindMouse(xs, ys, xe, ye, gravity, wind, minWait,
      maxWait, targetArea: extended; reverse: boolean);

Mouse movement based on distance to determine speed. Default slowed
speed at 20% from destination, if Double is set to true then slowed
speed also starts at origin and ends 80% to destination.

.. note::

    by BenLand100 & Flight

Example:

.. code-block:: pascal

    See mouse().

*}
procedure _brakeWindMouse(xs, ys, xe, ye, gravity, wind, minWait, maxWait,
          targetArea: extended; double: boolean);
var
  veloX,veloY,windX,windY,veloMag,dist,randomDist,lastDist,D: extended;
  lastX,lastY,MSP,W,TDist,T: integer;
  sqrt2,sqrt3,sqrt5,PDist,maxStep,dModA,dModB,nModA,nModB: extended;
begin
  MSP  := mouseSpeed;
  sqrt2:= sqrt(2);
  sqrt3:= sqrt(3);
  sqrt5:= sqrt(5);

  TDist := distance(round(xs), round(ys), round(xe), round(ye));
  if (TDist < 1) then
    TDist := 1;

  dModA := 0.88; //.80
  dModB := 0.95; //.90

  if (TDist > 220) then
  begin
    nModA := 0.08;
    nModB := 0.04;
  end else if (TDist <= 220) then
  begin
    nModA := 0.20;
    nModB := 0.10;
  end;

  t := getSystemTime + 5000;
  repeat
    if (getSystemTime > t) then
      break;

    dist:= hypot(xs - xe, ys - ye);
    wind:= minE(wind, dist);
    if (dist < 1) then
      dist := 1;
    PDist := (dist/TDist);
    if (PDist < 0.01) then
      PDist := 0.01;

    if double then
    begin
      if (PDist <= dModA) then
      begin
        D := (round((round(dist)*0.3))/5);
        if (D < 20) then
          D := 20;

      end else if (PDist > dModA) then
      begin
        if (PDist < dModB) then
          D := randomRange(5, 8)
        else if (PDist >= dModB) then
          D := randomRange(3, 4);
      end;
    end;

    if (PDist >= nModA) then
    begin
       D := (round((round(dist)*0.3))/5);
      if (D < 20) then
        D := 20;
    end else if (PDist < nModA) then
    begin
      if (PDist >= nModB) then
        D := randomRange(5, 8)
      else if (PDist < nModB) then
        D := randomRange(3, 4);
    end;

    if (D <= round(dist)) then
      maxStep := D
    else
      maxStep := round(dist);

    if dist >= targetArea then
    begin
      windX:= windX / sqrt3 + (random(round(wind) * 2 + 1) - wind) / sqrt5;
      windY:= windY / sqrt3 + (random(round(wind) * 2 + 1) - wind) / sqrt5;
    end else
    begin
      windX:= windX / sqrt2;
      windY:= windY / sqrt2;
    end;

    veloX:= veloX + windX;
    veloY:= veloY + windY;
    veloX:= veloX + gravity * (xe - xs) / dist;
    veloY:= veloY + gravity * (ye - ys) / dist;

    if (hypot(veloX, veloY) > maxStep) then
    begin
      randomDist:= maxStep / 2.0 + random(round(maxStep) div 2);
      veloMag:= sqrt(veloX * veloX + veloY * veloY);
      veloX:= (veloX / veloMag) * randomDist;
      veloY:= (veloY / veloMag) * randomDist;
    end;

    lastX:= round(xs);
    lastY:= round(ys);
    xs:= xs + veloX;
    ys:= ys + veloY;

    if (lastX <> round(xs)) or (lastY <> round(ys)) then
      moveMouse(round(xs), round(ys));

    W := (random((round(100/MSP)))*6);
    if (W < 5) then
      W := 5;
    if double then
      if (PDist > dModA) then
        W := round(W*2.5)
    else
      W := round(W*1.2);
    wait(W);
    lastdist:= dist;
  until(hypot(xs - xe, ys - ye) < 1)

  if (round(xe) <> round(xs)) or (round(ye) <> round(ys)) then
    moveMouse(round(xe), round(ye));

  mouseSpeed := MSP;
end;

{*
_humanWindMouse
~~~~~~~~~~~~~~~

.. code-block:: pascal

    procedure _humanWindMouse(xs, ys, xe, ye, gravity, wind, minWait,
      maxWait, targetArea: extended);

Description: FLIGHT YOU NEED TO GIVE ME SOMETHING FOR THIS! ;)

.. note::

    by BenLand100 & Flight

Example:

.. code-block:: pascal

    See mouse().
*}
procedure _humanWindMouse(xs, ys, xe, ye, gravity, wind, minWait, maxWait, targetArea: extended);
var
  veloX,veloY,windX,windY,veloMag,dist,randomDist,lastDist,D: extended;
  lastX,lastY,MSP,W,T,TDist: integer;
  sqrt2,sqrt3,sqrt5,maxStep,rCnc: extended;
begin
  MSP  := mouseSpeed;
  sqrt2:= sqrt(2);
  sqrt3:= sqrt(3);
  sqrt5:= sqrt(5);

  TDist := distance(round(xs), round(ys), round(xe), round(ye));
  t := getSystemTime + 10000;
  repeat
    if (getSystemTime > t) then
      break;

    dist:= hypot(xs - xe, ys - ye);
    wind:= minE(wind, dist);
    if (dist < 1) then
      dist := 1;

    D := (round((round(TDist)*0.3))/7);
    if (D > 25) then
      D := 25;
    if (D < 5) then
      D := 5;

    rCnc := random(6);
    if (rCnc = 1) then
      D := randomRange(2,3);

    if (D <= round(dist)) then
      maxStep := D
    else
      maxStep := round(dist);

    if dist >= targetArea then
    begin
      windX:= windX / sqrt3 + (random(round(wind) * 2 + 1) - wind) / sqrt5;
      windY:= windY / sqrt3 + (random(round(wind) * 2 + 1) - wind) / sqrt5;
    end else
    begin
      windX:= windX / sqrt2;
      windY:= windY / sqrt2;
    end;

    veloX:= veloX + windX;
    veloY:= veloY + windY;
    veloX:= veloX + gravity * (xe - xs) / dist;
    veloY:= veloY + gravity * (ye - ys) / dist;

    if (hypot(veloX, veloY) > maxStep) then
    begin
      randomDist:= maxStep / 2.0 + random(round(maxStep) div 2);
      veloMag:= sqrt(veloX * veloX + veloY * veloY);
      veloX:= (veloX / veloMag) * randomDist;
      veloY:= (veloY / veloMag) * randomDist;
    end;

    lastX:= round(xs);
    lastY:= round(ys);
    xs:= xs + veloX;
    ys:= ys + veloY;

    if (lastX <> round(xs)) or (lastY <> round(ys)) then
      moveMouse(round(xs), round(ys));

    W := (random((round(100/MSP)))*6);
    if (W < 5) then
      W := 5;
    W := round(W*0.9);
    wait(W);
    lastdist:= dist;
  until(hypot(xs - xe, ys - ye) < 1)

  if (round(xe) <> round(xs)) or (round(ye) <> round(ys)) then
    moveMouse(round(xe), round(ye));

  mouseSpeed := MSP;
end;

(*
fastClick
~~~~~~~~~

.. code-block:: pascal

    procedure fastClick(button: integer);

Quickly click the mouse with any button.

.. note::

    by Flight

Example:

.. code-block:: pascal

    fastClick(MOUSE_LEFT);

*)
procedure fastClick(button: integer);
var
  x, y: integer;
begin
  if (button = MOUSE_MOVE) then Exit;
  getMousePos(x, y);
  holdMouse(x, y, button);

  wait(randomRange(60, 150));

  getMousePos(x, y);
  releaseMouse(x, y, button);
end;

(*
mouse
~~~~~

.. code-block:: pascal

    procedure mouse(pnt: TPoint; button: integer; mmType: integer = MOUSE_HUMAN); overload;

Moves the mouse to 'pnt' using specified 'mmType' then clicks the mouse 'button'.

.. note::

    by NCDS & Flight

Example:

.. code-block:: pascal

    mouse(point, mouse_Left, MOUSE_ACCURATE);

*)
procedure mouse(pnt: TPoint; button: integer; mmType: integer = MOUSE_HUMAN); overload;
var
  randSpeed: extended;
  x,y,ms: integer;
begin
  if (button = MOUSE_NONE) then
    exit;

  ms := mouseSpeed;
  randSpeed := (random(mouseSpeed) / 2.0 + mouseSpeed) / 10.0;
  getMousePos(x,y);

  if mmType = MOUSE_HUMAN then
    _humanWindMouse(x, y, pnt.x, pnt.y, MOUSE_HUMAN, 5, 10.0/randSpeed, 15.0/randSpeed, 10.0*randSpeed)
  else
    _brakeWindMouse(x, y, pnt.x, pnt.y, mmType, 3, 10.0/randSpeed, 15.0/randSpeed, 10.0*randSpeed, false);

  mouseSpeed := ms;
  fastClick(button);
end;

(*
mouse() overload;
~~~~~~~~~~~~~~~~~

.. code-block:: pascal

    procedure mouse(pnt: TPoint); overload;

Moves the mouse to 'pnt'.

.. note::

    by NCDS & Flight

Example:

.. code-block:: pascal

    mouse(point);
*)
procedure mouse(pnt: TPoint); overload;
begin
  mouse(pnt, MOUSE_MOVE);
end;

(*
missMouse
~~~~~~~~~

.. code-block:: pascal

    procedure missMouse(pnt: TPoint);

Moves the mouse, but initially misses the target point (miss area determined by dist & speed) then corrects itself.

.. note::

    by Flight

Example:

.. code-block:: pascal

    missMouse(point);

*)
procedure missMouse(pnt: TPoint);
var
  randSpeed: extended;
  x,y,x2,y2,a,dist,mp: integer;
begin
  a := mouseSpeed;
  getMousePos(x, y);
  dist := distance(x, y, pnt.x, pnt.y);
  mp := round(dist/150);
  if mp < 0 then
    mp := 1;

  randSpeed := (random(mouseSpeed) / 2.0 + mouseSpeed) / 10.0;
  x2 := randomRange(Pnt.x-(a*mp), Pnt.x+(a*mp));
  y2 := randomRange(Pnt.y-(a*mp), Pnt.y+(a*mp));
  _humanWindMouse(x, y, x2, y2, MOUSE_HUMAN, 5, 10.0/randSpeed, 15.0/randSpeed, 10.0*randSpeed);
  getMousePos(x, y);
  mouse(pnt);
  mouseSpeed := a;
end;

(*
dragMouse
~~~~~~~~~

.. code-block:: pascal

    procedure dragMouse(dest: TPoint);

Clicks MOUSE_LEFT at current position and drags to dest(ination).

.. note::

    by NCDS & Naum

Example:

.. code-block:: pascal

    dragMouse(point);

*)
procedure dragMouse(dest: TPoint);
var
  x, y: integer;
begin
  getMousePos(x, y);
  holdMouse(x, y, MOUSE_LEFT);
  wait(random(100));
  mouse(dest);
  getMousePos(x, y);
  wait(random(100));
  releaseMouse(x, y, MOUSE_LEFT);
end;

(*
mouseBox
~~~~~~~~

.. code-block:: pascal

    procedure mouseBox(b: TBox; button: integer = MOUSE_MOVE);

Moves the mouse somewhere inside the box b. Will just move my default. Click
depends on what button is set to.  It is more likely to click around the middle
of the box.

.. note::

    by Coh3n
    Last Updated: Mar. 17, 2013 by Coh3n

Example:

.. code-block:: pascal

    mouseBox(b, MOUSE_LEFT);
*)
procedure mouseBox(b: TBox; button: integer = MOUSE_MOVE);
var
  p: TPoint;
  x, y: integer;
begin
  getMousePos(x, y);

  if (not pointInBox(point(x, y), b)) then // if the mouse is already in the box
  begin
    gaussBox(p, b);
    mouse(p, button);
  end else
    mouse(point(x, y), button);
end;

(*
mouseOval
~~~~~~~~~

.. code-block:: pascal

    procedure mouseOval(cx, cy, rx, ry, mouseAction: Integer = MOUSE_MOVE);

Clicks a random point within an oval shape.
    * cx, cy: The center point of the oval.
    * rx, ry: X and Y radius of the oval.
    * mouseAction: the action of the mouse. Default set to MOUSE_MOVE;

.. note::

    by mixster
    Last Updated: Mar. 16, 2013 by Coh3n

Example:

.. code-block:: pascal

    mouseOval(100, 100, 50, 30);
*)
procedure mouseOval(cx, cy, rx, ry, mouseAction: Integer = MOUSE_MOVE);
var
  o: TPoint;
begin
  o.y := random(ry) * ((random(2) * 2) - 1);
  o.x := random(round(sqrt(sqr(ry) - sqr(o.y)) * rx / ry)) * ((random(2) * 2) - 1);

  mouse(point(cx + o.x, cy + o.y), mouseAction);
end;

(*
mouseCircle
~~~~~~~~~~~

.. code-block:: pascal

    procedure mouseCircle(MidX, MidY, Radius, mouseAction: Integer = MOUSE_MOVE);

Same as mouseOval, but mouses within a circle instead.

.. note::

    by mixster
    Last Updated: Mar. 21st, 2012 by Coh3n

Example:

.. code-block:: pascal

    mouseCircle(50, 50, 25);
*)
procedure mouseCircle(MidX, MidY, Radius, mouseAction: Integer = MOUSE_MOVE);
begin
  mouseOval(MidX, MidY, Radius, Radius, mouseAction);
end;

(*
didClick
~~~~~~~~

.. code-block:: pascal

    function didClick(Red: Boolean; Time: Integer = 1000): boolean;

Clicks the current mouse position and looks for the colored X. Times out after
Time.  Time default set to 1000.

.. note::

    by Rasta Magician & Narcle
    Last Updated: Mar. 16, 2013 by Coh3n

Example:

.. code-block:: pascal

    if (didClick(true)) then
      writeln('Clicked object!');
*)
function didClick(Red: Boolean; Time: Integer = 1000): boolean;
var
  TimeOut, x, y, w, h, R, G: integer;
  B: TBox;
begin
  fastClick(MOUSE_LEFT);

  GetMousePos(x, y);
  GetClientDimensions(w, h);
  B := IntToBox(x - 15, y - 15, x + 15, y + 15);

  if (B.x1 < 0) then B.x1 := 0;
  if (B.y1 < 0) then B.y1 := 0;
  if (B.x2 > w) then B.x2 := w;
  if (B.y2 > h) then B.y2 := h;

  TimeOut := GetSystemTime + Time;

  while (GetSystemTime < TimeOut) and (not Result) do
  begin
    R := CountColorTolerance(395675, B.x1, B.y1, B.x2, B.y2, 15);
    G := CountColorTolerance(1695663, B.x1, B.y1, B.x2, B.y2, 15);

    if Red then
    begin
      if (G > 8) then
        Exit(false);

      Result := (R > 20);
    end else
    begin
      if (R > 5) then
        Exit(false);

      Result := (G > 35);
    end;
  end;
end;

(*
multiClick
~~~~~~~~~~

.. code-block:: pascal

  function multiClick(p: TPoint; chance, maxClicks: integer): boolean;

Will simulate "spam" clicking on the point, p.  Will do it a random amount
between 1 and 'maxClicks'.  Will always click once, then has a percent
'chance' of clicking again.  Will not exceed 'maxClicks'.

.. note::

  | Author: Coh3n
  | Last Updated: 16 March 2013 by Coh3n

Example:

.. code-block:: pascal

  if (mainscreen.isUptext('Tree')) then
    multiClick(p, 35, 5, true);
*)
function multiClick(p: TPoint; chance, maxClicks: integer): boolean;
var
  clicks: integer;
begin
  result := true;

  repeat
    inc(clicks);
    mouse(p, MOUSE_LEFT);

    if (random(100) > chance) or (not result) then
      break;

    wait(50 + random(50));
  until(clicks >= maxClicks);
end;

