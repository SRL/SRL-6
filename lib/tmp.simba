(*
Temporary Functions
===================

This file stores data utilized by SRL that will eventually be a part of Simba
and/or Lape.

*)

{$f-}

const
  MOUSE_NONE = -1;
  MOUSE_MOVE = 3;

var
  clWhite = 16777215;
  clBlack = 0;
  clRed = 255;
  clGreen = 32768;
  clBlue = 16711680;
  clPurple = 8388736;
  clYellow = 65535;
  clAqua = 16776960;
  clOrange = 26367;
  clFuchsia = 16711935;
  clTeal = 8421376;
  clNavy = 8388608;
  clGray = 8421504;
  clLime = 65280;
  clMaroon = 128;
  clSilver = 12632256;
  clPink = 11772650;

var
  maxInt = high(integer);

var
  __onTerminateProcs: TStringArray;

(*
terminateScript; override;
~~~~~~~~~~~~~~~~~~~~~~~~~~

.. code-block:: pascal

    procedure terminateScript; override;

Calls add on terminate procedures and then continues with terminating the script.

.. note::

    by: core

Example:

.. code-block:: pascal

  terminateScript();

*)
procedure terminateScript; override;
var
  i, h: integer;
begin
  h := high(__onTerminateProcs);

  for i := 0 to h do
    variantInvoke(__onTerminateProcs[i]);

  writeln('-- terminateScript: Called procedures ' + toStr(__onTerminateProcs));

  inherited();
end;

(*
addOnTerminate
~~~~~~~~~~~~~~

.. code-block:: pascal

    procedure addOnTerminate(const proc: string);

Adds a procedure (proc) to be called apon script being terminated, will only be
called if terminateScript is called, if the script ends "naturally" the proc
will not be called.


.. note::

    by: core

Example:

.. code-block:: pascal

  addOnTerminate('freeMyDTMs');

*)
procedure addOnTerminate(const proc: string);
var
  i, h: Integer;
begin
  h := high(__onTerminateProcs);

  for i := 0 to h do
    if (__onTerminateProcs[i] = proc) then
      exit();

  setLength(__onTerminateProcs, h + 2);
  __onTerminateProcs[h + 1] := proc;
end;

(*
addOnTerminate; overload;
~~~~~~~~~~~~~~~~~~~~~~~~~

.. code-block:: pascal

    procedure addOnTerminate(const procArr: TStringArray); overload;

Accepts multiple procedures at once to be added.

.. note::

    by: Ollybest

Example:

.. code-block:: pascal

  addOnTerminate(['freeMyDTMs', 'freeMyBitmaps']);

*)
procedure addOnTerminate(const procArr: TStringArray); overload;
var
  i, h: integer;
begin
  h := high(procArr);

  for i := 0 to h do
    addOnTerminate(procArr[i]);
end;

(*
freeDTMs
~~~~~~~~

.. code-block:: pascal

    procedure freeDTMs(DTMs: TIntegerArray);

Free's an array of DTMs.

.. note::

    by Ollybest

Example:

.. code-block:: pascal

     freeDTMs([dtm1, dtm2]);

*)
procedure freeDTMs(DTMs: TIntegerArray);
var
  i: integer;
begin
  for i := 0 to high(dtms) do
    freeDTM(dtms[i]);
end;

(*
freeBitmaps
~~~~~~~~~~~

.. code-block:: pascal

    procedure freeBitmaps(bitmaps: TIntegerArray);

Free's an array of bitmaps.

.. note::

    by Ollybest

Example:

.. code-block:: pascal

     freeBitmaps([bmp1, bmp2]);

*)
procedure freeBitmaps(bitmaps: TIntegerArray);
var
  i: integer;
begin
  for i := 0 to high(bitmaps) do
    freeBitmap(bitmaps[i]);
end;

(*
getMostCommonNumber
~~~~~~~~~~~~~~~~~~~

.. code-block:: pascal

    function getMostCommonNumber(Arr: TIntegerArray): LongInt;

Returns the most common number in the array, useful for finding the most common
color in a TPointArray.

.. note::

    by Dgby714

Example:

.. code-block:: pascal

     mostCol := getMostCommonNumber(getColors(tpa));

*)
function getMostCommonNumber(Arr: TIntegerArray): LongInt;
var
  H, I, Cur, Count, HighCount: LongInt;
begin
  QuickSort(Arr);

  Cur := Arr[0] - 1;
  Count := 0;
  HighCount := 0;

  H := High(Arr);
  for I := 0 to H do
  begin
    if (Cur <> Arr[I]) then
    begin
      if (Count > HighCount) then
      begin
        HighCount := Count;
        Result := Cur;
      end;

      Count := 0;
      Cur := Arr[I];
    end;

    Inc(Count);
  end;
end;

(*
sendKeyWait
~~~~~~~~~~~

.. code-block:: pascal

    procedure sendKeyWait(key: Byte; waitTime: integer);

Holds down the desired key for the set waitTime.

.. note::

    by Ollybest

Example:

.. code-block:: pascal

     sendKeyWait(vk_up, 800 + random(200));

*)
procedure sendKeyWait(key: Byte; waitTime: integer);
begin
  if (not (isKeyDown(key))) then
    keyDown(key);

  wait(waitTime);

  if isKeyDown(key) then
    keyUp(key);
end;

(*
intToPoint
~~~~~~~~~~

.. code-block:: pascal

    function intToPoint(x, y: integer): TPoint;

Converts 2 integers into a TPoint.

.. note::

    by Ollybest

Example:

.. code-block:: pascal

     point := intToPoint(i,ii);

*)
function intToPoint(x, y: integer): TPoint;
begin
  result := point(x, y);
end;

(*
GridBox
~~~~~~~

.. code-block:: pascal

    function GridBox(slot, columns, rows, w, h, diffX, diffY: integer; starTPoint: TPoint): TBox;

Returns a TBox of the slot 'slot' in a grid created by the other parameters.
Slots start with 0 being the top left of the grid, and counting accross.
    * columns: number of columns in the grid
    * rows: number of rows in the grid
    * w: the width of each box in the grid
    * h: the height of each box in the grid
    * diffX: pixels from center to center (x)
    * diffY: pixels from center to center (y)
    * starTPoint: the center point of the top left box in the grid

.. note::

    | Author: Coh3n
    | Last Modified: Jan. 25th, 2012 by Coh3n

Example:

.. code-block:: pascal

    result := GridBox(Slot, 4, 2, 95, 80, 0, 150, point(110, 100));
*)
function GridBox(slot, columns, rows, w, h, diffX, diffY: integer; startPoint: TPoint): TBox;
begin
  if (slot > (columns * rows)) then
  begin
    writeln('GridBox: Invalid slot: '+toStr(slot));
    exit;
  end;

  result.x1 := (startPoint.x + ((slot mod columns) * diffX) - (w div 2));
  result.y1 := (startPoint.y + ((slot div columns) * diffY) - (h div 2));
  result.x2 := (result.x1 + w);
  result.y2 := (result.y1 + h);
end;

(*
Grid
~~~~

.. code-block:: pascal

    function Grid(columns, rows, w, h, diffX, diffY: integer; starTPoint: TPoint): TBoxArray;

Returns a grid of TBoxes (see GridBox for parameters).

.. note::

    | Author: Coh3n
    | Last Modified: Jan. 25th, 2012 by Coh3n

Example:

.. code-block:: pascal

    SMART_DrawBoxes(false, Grid(5, 10, 20, 20, 25, 25, point(30, 30)), clYellow);
*)
function Grid(columns, rows, w, h, diffX, diffY: integer; starTPoint: TPoint): TBoxArray;
var
  i: integer;
begin
  setLength(result, (columns * rows));

  for i := 0 to high(result) do
    result[i] := GridBox(i, columns, rows, w, h, diffX, diffY, starTPoint);
end;

(*
GroupDigits
~~~~~~~~~~~

.. code-block:: pascal

    function GroupDigits(n: integer; token: String): String;

Nicely formats the number passed by placing *token* in between groups of three
numbers.

.. note::

    by PriSoner and Nava2

Example:

.. code-block:: pascal

    foo := GroupDigits(1000, ','); // foo -> '1,000'
    bar := GroupDigits(1500423, ' '); // bar -> '1 500 423'

*)
function GroupDigits(n: integer; token: String): String;
var
  b: integer;
begin
  Result := IntToStr(n);

  b := length(Result) + 1;
  if (b > 3) then
  repeat
    b := b - 3;
    if (b > 1) then
      insert(token, Result, b);
  until (b < 3);
end;

(*
__gaussRand
~~~~~~~~~~~

This is a functional pointer. It behaves transparently as a regular function
would. This function will behave as so: it will return a random Extended
normally distributed with a mean of 0 and a standard deviation of 1.

If you need more flexibility in this (ex. mean of 2), please use GaussRandom
which converts between the Standard Normal and a custom version.

.. note::

    by: SRL Development Team

Example:

.. code-block:: pascal


*)

var
  __gaussPoint: extended;
  __gaussRange: extended;
  __gaussRand: function: extended;

{

Helper method for cal_normal_random. Does polynomial calculation using the
`Horner Scheme`_

..http://en.wikipedia.org/wiki/Horner_scheme

}
const
  __gauss_norm_0 = 0.029899776;
  __gauss_norm_1 = 0.008355968;
  __gauss_norm_2 = 0.076542912;
  __gauss_norm_3 = 0.252408784;
  __gauss_norm_4 = 3.949846138;

function __gaussPoly(r, rsqr: Extended): Extended;
begin
  Result := __gauss_norm_0*rsqr + __gauss_norm_1;
  Result := Result*rsqr + __gauss_norm_2;
  Result := Result*rsqr + __gauss_norm_3;
  Result := Result*rsqr + __gauss_norm_4;
  Result := Result*r;
end;

(*
Gauss
~~~~~

.. code-block:: pascal

    function Gauss(): Extended;

Calculates a standard normal value (N(0, 1)).

By definition, 68.2% of points will lie within +/- 1*sigma, 95.4% within +/- 2.

.. note::

    by: Nava2

*)
function Gauss(): Extended;
var
  r: Extended;
  i: Integer;
begin
  r := 0.0;
  for i := 0 to 11 do
    r := r + (random(MaxInt)*1.0)/MaxInt;

  r := (r-6.0)/4.0 ;
  result := __gaussPoly(r, r*r);
end;

(*
__gaussMarsPolar
~~~~~~~~~~~~~~~~

.. code-block:: pascal

    function __gaussMarsPolar(): Extended;

Calculates a standard normal value (N(0, 1]).

By definition, 68.2% of points will lie within +/- 1*sigma, 95.4% within +/- 2.

.. note::
    Please use `__gaussRand` instead of this function directly, feel free to
    set `__gaussRand` to this function if you choose.
    Currently, this is the default.

.. note::
    by: BenLand100

*)
function __gaussMarsPolar(): Extended;
begin
  Result := sqrt(-2.0*ln(RandomE()))*cos(2.0*PI*RandomE());
end;

(*
GaussRand
~~~~~~~~~

..code-block:: pascal

    function GaussRand(mean, dev: Extended): Extended;

Calculates a normally distributed point around mean (u) with a standard
deviation of dev (o).

..note::

   by: Nava2

Example:

..code-block:: pascal

    // shooting arrows simulation:
    pt := Point(GaussRand(center.x, 0.5), GaussRand(center.y, 0.5));
    WriteLn(Format('Hit the target at (%d, %d).', [pt.x, pt.y]));

*)

function GaussRand(mean, dev: Extended): Extended;
begin
  result := mean + dev*__gaussRand();
end;


(*
GaussPoint
~~~~~~~~~~~

.. code-block:: pascal

    procedure GaussPoint(cX, cY: Integer; sAngle, eAngle: Extended; maxRad: Integer; out oX, oY: Integer);

Calculates a point about cX, cY with radius maxRad. The sangle and eangle are
in radians. The point is returned in the reference parameters oX, oY.

.. note::

    by: Nava2

Example:

.. code-block:: pascal

    var
      gX, gY: Integer;
    // get a gaussian pt in a circle:
    GaussPoint(MMCX, MMCY, 0, math_2PI, MMX2-MMCX, gX, gY);
    WriteLn(Format("gX, gY -> %d, %d", gX, gY);

*)

procedure GaussPoint(cX, cY: Integer; sAngle, eAngle: Extended; maxRad: Integer; out oX, oY: Integer);
var
  angle: Extended;
  radius: Extended;
  xShift, yShift: Integer;
begin

  if (eAngle < sAngle) then
    swap(eAngle, sAngle);

  { random angle about the center }
  angle := sAngle + (eAngle-sAngle)*__gaussRand()/2.0;

  { get normal pt about zero, where 68% lie within .5*maxRad }
  radius := GaussRand(maxRad,maxRad*__gaussPoint) - maxRad;


  { the shifting distance based on the radius and angle (both rand) }
  xShift := round(radius * Cos(angle));
  yShift := round(radius * Sin(angle));

  oX := cX + xShift;
  oY := cY + yShift;
end;

(*
GaussRangeExt
~~~~~~~~~~~~~

.. code-block:: pascal

    function GaussRangeExt(minI, maxI: Extended): Extended;

Returns a number between minI and maxI that is normally distributed in the range.

.. note::

  by: Nava2

Example:

.. code-block:: pascal

    randMean := GaussRangeExt(0, 20);

*)
function GaussRangeExt(minI, maxI: Extended): Extended;
var
  valid: Boolean;
  mean: Extended;
  dev: Extended;
  t: Integer;
begin
  { calculate the mean }
  mean := (maxI+minI)/2.0;
  dev  := abs(maxI-minI)/2.0 * __gaussRange;

  t := 0;
  while ((not valid) and (t < 100)) do
  begin
    Result := GaussRand(mean, dev);
    valid := ((Result >= minI) and (Result <= MaxI));

    inc(t);
  end;

end;

(*
GaussRangeInt
~~~~~~~~~~~~~

.. code-block:: pascal

    function GaussRangeInt(minI, maxI: Integer): Integer;

See `GaussRangeExt` for more detail. Same function, but with integers.

.. note::

    by: Nava2

*)
function GaussRangeInt(minI, maxI: Integer): Integer;
begin
  Result := Round(GaussRangeExt(minI, maxI));
end;

(*
GaussRandom
~~~~~~~~~~~

.. code-block:: pascal

    function GaussRandom(maxExt: Integer): Integer;

Computes a normally distributed number in [0, maxExt). Thus, it behaves like
Random() would be expected to. But normally distributed about maxExt/2.

It is a wrapper for `GaussRangeInt`.

.. note::

    by Nava2

Example:

.. code-block:: pascal

*)
function GaussRandom(maxExt: Integer): Integer;
begin
  Result := GaussRangeInt(0, maxExt-1);
end;

(*
GaussBox
~~~~~~~~

.. code-block:: pascal

    procedure GaussBox(out px, py: Integer; x1, y1, x2, y2: Integer);

Calculates a point normally distributed from the center of the passed box. It
checks for outlying points and will regenerate points if necessary.

.. note::

    by: Nava2

Example:

.. code-block:: pascal

    var
      gX, gY: Integer;

    // get a gaussian pt in a circle:
    Gauss_Box(gX, gY, MMX1, MMY1, MMX2, MMY2);
    WriteLn(Format("gX, gY -> %d, %d", gX, gY);

*)
procedure GaussBox(out p: TPoint; box: TBox);
begin
  p.x := GaussRangeInt(box.x1, box.x2);
  p.y := GaussRangeInt(box.y1, box.y2);

  if (not PointInBox(p, box)) then
    writeln('GaussBox',Format('Point invalid (%d, %d)', [p.x, p.y]));
end;

begin
  __gaussPoint := 0.4;
  __gaussRange := 0.3;
  __gaussRand := __gaussMarsPolar;
end;
