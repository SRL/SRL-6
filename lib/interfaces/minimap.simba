(*
Minimap
=======

The minimap file holds all SRL's functions that interact with the Runescape
minimap.

The source for this file can be found `here <https://github.com/SRL/SRL-6/blob/master/lib/interfaces/minimap.simba>`_.

*)

{$include_once interfaces.simba}
{$include_once ../utilities/color.simba}
{$include_once ../utilities/pixelshift.simba}
{$include_once ../core/text.simba}
{$f-}

(*
const Direction
~~~~~~~~~~~~~~~

Constants that represent the NESW directions on the compass.  Meant to be used
with compass altering functions.

Example:

.. code-block:: pascal

    minimap.setAngle(MM_DIRECTION_EAST);
*)
const
  MM_DIRECTION_NORTH = 0;
  MM_DIRECTION_EAST  = 90;
  MM_DIRECTION_SOUTH = 180;
  MM_DIRECTION_WEST  = 270;

(*
const Minimap Dots
~~~~~~~~~~~~~~~~~~

Constants representing the different dots that appear on the minimap.  Each value
represents the difference between the two bottom colored pixels of each dot. DO
NOT modify these values unless you know what you're doing.

These constants are meant to be used with functions that take a minimap dot type
as a parameter (such as minimap.getDots).

Example:

.. code-block:: pascal

    tpa := minimap.getDots(MM_DOT_NPC, minimap.getBounds());

    if (length(tpa) > 0) then
      writeln('Found '+toStr(length(tpa))+' NPC dots on the minimap');

*)
const
  MM_DOT_NPC    = 4369;
  MM_DOT_ITEM   = 23;
  MM_DOT_PLAYER = 1907997;
  MM_DOT_FRIEND = 5376;
  MM_DOT_TEAM   = 2171941;

(*
const PixelCount
~~~~~~~~~~~~~~~~

Stores the max pixel count of the minimap (the actual map area).

Example:

.. code-block:: pascal

*)
const
  MM_PIXEL_COUNT = 35785;

(*
const Locations
~~~~~~~~~~~~~~~

All possible locations to teleport on the lodestone network.

Example:

.. code-block:: pascal

*)
const
  LOCATION_LUNAR_ISLE      = 0;
  LOCATION_EAGLES_PEAK     = 1;
  LOCATION_TIRANNWN        = 2;
  LOCATION_FREMENNIK       = 3;
  LOCATION_SEERS_VILLAGE   = 4;
  LOCATION_ARDOUGNE        = 5;
  LOCATION_YANILLE         = 6;
  LOCATION_OOGLOG          = 7;
  LOCATION_BURTHORPE       = 8;
  LOCATION_CATHERBY        = 9;
  LOCATION_TRAVERLEY       = 10;
  LOCATION_KARAMJA         = 11;
  LOCATION_WILDERNESS      = 12;
  LOCATION_EDGEVILLE       = 13;
  LOCATION_FALADOR         = 14;
  LOCATION_PORT_SARIM      = 15;
  LOCATION_VARROCK         = 16;
  LOCATION_DRAYNOR_VILLAGE = 17;
  LOCATION_LUMBRIDGE       = 18;
  LOCATION_BANDIT_CAMP     = 19;
  LOCATION_AL_KHARID       = 20;
  LOCATION_CANIFIS         = 21;
  LOCATION_PREVIOUS        = 1337;


(*
const Symbols
~~~~~~~~~~~~~

Constants representing all the Runescape symbols.  Each have a bitmap that can
be found in _getSymbol and are used in the symbol finding functions.

Example:

.. code-block:: pascal

    if (minimap.findSymbol(p, MM_SYMBOL_BANK, minimap.getBounds)) then
      writeln('Found bank symbol!');
*)
const
  MM_SYMBOL_SHOP_ARCHERY    = 0;
  MM_SYMBOL_SHOP_AXE        = 1;
  MM_SYMBOL_SHOP_CANDLE     = 2;
  MM_SYMBOL_SHOP_CLOTHES    = 3;
  MM_SYMBOL_SHOP_COOKERY    = 4;
  MM_SYMBOL_SHOP_CRAFTING   = 5;
  MM_SYMBOL_SHOP_FARMING    = 6;
  MM_SYMBOL_SHOP_FISHING    = 7;
  MM_SYMBOL_SHOP_FOOD       = 8;
  MM_SYMBOL_SHOP_HUNTER     = 9;
  MM_SYMBOL_SHOP_KEBAB      = 10;
  MM_SYMBOL_SHOP_MACE       = 11;
  MM_SYMBOL_SHOP_MAGIC      = 12;
  MM_SYMBOL_SHOP_PET        = 13;
  MM_SYMBOL_SHOP_PLATEBODY  = 14;
  MM_SYMBOL_SHOP_PLATESKIRT = 15;
  MM_SYMBOL_SHOP_SCIMITAR   = 16;
  MM_SYMBOL_SHOP_SHIELD     = 17;
  MM_SYMBOL_SHOP_MINING     = 18;
  MM_SYMBOL_SHOP_SWORD      = 19;
  MM_SYMBOL_SHOP_STAFF      = 20;
  MM_SYMBOL_SHOP_SUMMONING  = 21;

  MM_SYMBOL_STALL_SPICE     = 30;
  MM_SYMBOL_STALL_GEM       = 31;
  MM_SYMBOL_STALL_SILK      = 32;
  MM_SYMBOL_STALL_SILVER    = 33;

  MM_SYMBOL_TREE            = 40;
  MM_SYMBOL_FARMING         = 41;
  MM_SYMBOL_FISHING         = 42;
  MM_SYMBOL_RUNECRAFTING    = 43;
  MM_SYMBOL_HUNTING         = 44;
  MM_SYMBOL_HOUSE           = 45;
  MM_SYMBOL_POTTERY         = 46;
  MM_SYMBOL_MINING          = 47;
  MM_SYMBOL_JEWELERY        = 48;
  MM_SYMBOL_SLAYER_CONTRACT = 49;
  MM_SYMBOL_SLAYER_MASTER   = 50;
  MM_SYMBOL_HERBALIST       = 51;
  MM_SYMBOL_WHEEL           = 52;
  MM_SYMBOL_OBELISK         = 53;
  MM_SYMBOL_TANNER          = 54;
  MM_SYMBOL_TRAINING_DUMMY  = 55;
  MM_SYMBOL_STORE           = 56;
  MM_SYMBOL_SHORTCUT        = 57;
  MM_SYMBOL_WEAVE           = 58;
  MM_SYMBOL_COOK            = 59;
  MM_SYMBOL_AGILITY         = 60;
  MM_SYMBOL_FURNACE         = 61;
  MM_SYMBOL_ALTAR           = 62;
  MM_SYMBOL_ANVIL           = 63;

  MM_SYMBOL_APOTHECARY      = 70;
  MM_SYMBOL_ARROW           = 71;
  MM_SYMBOL_BAR             = 72;
  MM_SYMBOL_BANK            = 73;
  MM_SYMBOL_LODESTONE       = 74;
  MM_SYMBOL_CHURN           = 75;
  MM_SYMBOL_DUNGEON         = 76;
  MM_SYMBOL_TRADER_FUR      = 77;
  MM_SYMBOL_SPOT_REST       = 78;
  MM_SYMBOL_GUIDE           = 79;
  MM_SYMBOL_HAIR_DRESSER    = 80;
  MM_SYMBOL_MAKEOVER_MAGE   = 81;
  MM_SYMBOL_MILL            = 82;
  MM_SYMBOL_MINIGAME        = 83;
  MM_SYMBOL_OBELISK_MINI    = 84;
  MM_SYMBOL_PORTAL          = 85;
  MM_SYMBOL_QUEST           = 86;
  MM_SYMBOL_WINDMILL        = 87;
  MM_SYMBOL_SAND            = 88;
  MM_SYMBOL_SAWMILL         = 89;
  MM_SYMBOL_TRANSPORTATION  = 90;
  MM_SYMBOL_UNDERGROUND     = 91;
  MM_SYMBOL_WATER           = 92;

(*
const Buttons
~~~~~~~~~~~~~

Constants representing the minimap buttons.

*)
const
  MM_BUTTON_COMPASS = 0;
  MM_BUTTON_RUN = 1;
  MM_BUTTON_LODESTONE = 2;
  MM_BUTTON_MAP = 3;

{*
type _TRSSymbol
~~~~~~~~~~~~~~~

A type that stores minimap symbol information. Used in the symbol finding functions.
*}
type
  _TRSSymbol = record
    name: string;
    bmp: integer;
    color: integer;
  end;

{*
type _TRSMMButton
~~~~~~~~~~~~~~~~~

A type that stores minimap button information.
*}
type
  _TRSMMButton = record
    bounds: TBox;
    center: TPoint;
    radius: byte;
  end;

{*
type TRSMinimap
~~~~~~~~~~~~~~~

A type that stores all the attributes and functions of the Runescape minimap.
*}
type
  TRSMinimap = record(TRSInterface)
    symbolAccuracy: extended;
    _maskTPA: TPointArray;
  end;

(*
var minimap
~~~~~~~~~~~

The variable that holds all minimap information. It used when calling any functions
in this file.

Example:

.. code-block:: pascal

    while (minimap.isFlagPresent()) do
    begin
      writeln('Waiting for flag to disappear');
      wait(200+random(300));
    end;
*)
var
  minimap: TRSMinimap;

{*
TRSMinimap.__init
~~~~~~~~~~~~~~~~~

.. code-block:: pascal

    procedure TRSMinimap.__init();

Initializes the TRSMinimap.

.. note::

    - by Coh3n
    - Last Updated: 23 May 2013 by Coh3n

Example:

.. code-block:: pascal

    minimap.__init();
*}
{$IFNDEF CODEINSIGHT}
procedure TRSMinimap.__init();
begin
  with self do
  begin
    name := 'RS Minimap';
    ID := ID_INTERFACE_MINIMAP;
    parentID := -1;
    static := true;
    symbolAccuracy := 0.65;
  end;
end;
{$ENDIF}

{*
TRSMinimap.__createMaskTPA
~~~~~~~~~~~~~~~~~~~~~~~~~~

.. code-block:: pascal

    procedure TRSMinimap.__createMaskTPA();

Creates a TPointArray (stored in minimap._maskTPA) of the points that aren't on
map in the minimap.

.. note::

    - by euphemism
    - Last Updated: 14 August 2013 by Olly

Example:

.. code-block:: pascal

    minimap.__createMaskTPA();
*}
{$IFNDEF CODEINSIGHT}
procedure TRSMinimap.__createMaskTPA();
var
  bounds: TBox;
  bmp, borderBmp, hh, i, tempBmp, ww, res: integer;
  drawingPoints: array [0..3] of TPoint;
begin
  bounds := self.getBounds();

  try

    bmp := bitmapFromString(63, 64, 'meJztztEKwjAAxdD9/09fQRCUzd' +
          'muXWO35D1wlsXMzC5bEppwsDyjFUfKKxpSXd6iLXXlM5pTUVbRotL' +
          'Wchy/SSpP/D3xjX7aLl68ePHixYsXfx18i1z8PfGNcvGUnMJ3kSP4' +
          'XvLx+I7ywfi+8pH47vIx+DPYtfja5TxzC/5/Ek8lnko8lXgq8VTiq' +
          'e6Ap5nbzStPAZ4G7jWvPLt4mva7eeX5gqdRpT0AxMo+2w==');

    getBitmapSize(bmp, ww, hh);
    bounds.offset(point(- bounds.x1, - bounds.y1));

    drawingPoints[0] := point(bounds.x1, bounds.y1);
    drawingPoints[1] := point(bounds.x2 - ww, bounds.y1);
    drawingPoints[2] := point(bounds.x2 - ww, bounds.y2 - hh);
    drawingPoints[3] := point(bounds.x1, bounds.y2 - hh);

    res := createBitmap(bounds.x2 - bounds.x1+1, bounds.y2 - bounds.y1 +1);
    fastDrawClear(res, clWhite);

    borderBmp := createBitmap(bounds.x2 - bounds.x1 - 12, bounds.y2 - bounds.y1 - 12);
    getMufasaBitmap(borderBmp).drawTransparent(6, 6, getMufasaBitmap(res));
    invertBitmap(res);

    for i := 0 to 3 do
    begin

      tempBmp := rotateBitmap(bmp, (- PI / 2) * i);
      getMufasaBitmap(tempBmp).drawTransparent(drawingPoints[i].x, drawingPoints[i].y, getMufasaBitmap(res));
      freeBitmap(tempBmp);
    end;
  finally

    freeBitmap(bmp);
    freeBitmap(borderBmp);
  end;

  findColorsBitmap(res, self._maskTPA, clBlack);
  self._maskTPA.offset([self.x, self.y]);

  if (length(self._maskTPA) > 0) then
    print('minimap.__createMaskTPA(): Succesfully created mask tpa', TDebug.SUB)
  else
    print('minimap.__createMaskTPA(): Failed to create mask tpa', TDebug.FATAL);

  freeBitmap(res);
end;
{$ENDIF}

{*
function TRSMinimap.__find(): boolean
~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~

.. code-block:: pascal

    function TRSMinimap.__find(useDebug: boolean = true): boolean;

Attempts to find the interface "minimap", will return if succesfull or not.  Will
print debug text if 'useDebug' is set to true.  Set to true by default.

.. note::

    - by euphemism
    - Last Updated: 13 August 2013 by Coh3n

Example:

.. code-block:: pascal

    minimap.__find();
*}
{$IFNDEF CODEINSIGHT}
function TRSMinimap.__find(useDebug: boolean = true): boolean;
const
  COMPASS_CENTER_POINT_COLOR  = 8508157;
  ARBITRARY_UNIQUE_COLOR_ON_WORLD_MAP_BUTTON = 4615518;
  COLORS: TIntegerArray = [COMPASS_CENTER_POINT_COLOR, ARBITRARY_UNIQUE_COLOR_ON_WORLD_MAP_BUTTON];

  COMPASS_CENTER_POINT_OFFSET: TPoint = [- 23, - 22];
  ARBITRARY_UNIQUE_COLOR_ON_WORLD_MAP_OFFSET: TPoint = [12, 28];
  OFFSETS: TPointArray = [COMPASS_CENTER_POINT_OFFSET, ARBITRARY_UNIQUE_COLOR_ON_WORLD_MAP_OFFSET];
var
  hh, i, ii, len, ww: integer;
  wasFound: boolean;
  searchBox: TBox;
  tpa: TPointArray;
  atpa: T2DPointArray;
  box: TBox;
begin
  if (useDebug) then
    print('TRSMinimap.__find()', TDebug.HEADER);

  result := false;
  box := intToBox(-1, -1, -1, -1);
  getClientDimensions(ww, hh);
  searchBox := intToBox(0, 0, ww - 1, hh - 1);

  for i := 0 to 1 do
  begin

    if (not findColorsTolerance(tpa, COLORS[i], searchBox, 1)) then //If we didn't find the color of the center of the compass
    begin
      if (useDebug) then
      begin
        print('Failed to find minimap color '+toStr(i)+' ('+toStr(COLORS[i])+')', TDebug.ERROR);
        print('TRSMinimap.__find(): False', TDebug.FOOTER);
      end;

      exit(false);
    end;

    wasFound := false;
    len := length(tpa);

    if (not (len = 1)) then //If we found more than one point, then we need to try to find the one for which we are looking
    begin
      if (useDebug) then
        print('Found too many points for color '+toStr(i)+' ('+toStr(COLORS[i])+'), filtering bad points...');

      atpa := splitTPAEx(tpa, 1, 1); //Group found points
      sortATPASize(atpa, false);

      for ii := 0 to (len - 1) do
        if (length(atpa[ii]) <> 1) then
        begin

          continue;
        end else
        begin

          wasFound := true;
          break;
        end;

      if (not wasFound) then
      begin
        if (useDebug) then
        begin
          print('Failed to find the proper length TPA for color '+toStr(i)+' ('+toStr(COLORS[i])+')', TDebug.ERROR);
          print('TRSMinimap.__find(): False', TDebug.FOOTER);
        end;

        exit(false);
      end;

      if (i = 1) then
        if (not ((atpa[ii][0].x > box.x1) and (atpa[ii][0].y > box.y1))) then
        begin
          if (useDebug) then
          begin
            print('Failed to find world map color right of compass color after filtering', TDebug.ERROR);
            print('TRSMinimap.__find(): False', TDebug.FOOTER);
          end;

          exit(false);
        end;

      if (useDebug) then
        print('Found color '+toStr(i)+' ('+toStr(COLORS[i])+') after filtering, setting minimap coordinates...');

      if (i = 0) then
      begin

        box.x1 := tpa[ii].x + OFFSETS[i].x;
        box.y1 := tpa[ii].y + OFFSETS[i].y;
      end else
      begin

        box.x2 := tpa[ii].x + OFFSETS[i].x;
        box.y2 := tpa[ii].y + OFFSETS[i].y;
      end;
    end else
    begin

      if (i = 1) then
        if (not ((tpa[0].x > box.x1) and (tpa[0].y > box.y1))) then
        begin
          if (useDebug) then
          begin
            print('Failed to find world map color right of compass color', TDebug.ERROR);
            print('TRSMinimap.__find(): False', TDebug.FOOTER);
          end;

          exit(false);
        end;

      if (useDebug) then
        print('Found color '+toStr(i)+' ('+toStr(COLORS[i])+'), setting minimap coordinates...');

      if (i = 0) then
      begin

        box.x1 := tpa[0].x + OFFSETS[i].x;
        box.y1 := tpa[0].y + OFFSETS[i].y;
      end else
      begin

        box.x2 := tpa[0].x + OFFSETS[i].x;
        box.y2 := tpa[0].y + OFFSETS[i].y;
      end;
    end;
  end;

  result := true;
  self.setBounds(box);
  self.__createMaskTPA();

  print('TRSMinimap.__find(): Sucesfully found and set minimap bounds at '+toStr(self.getBounds()));

  if (useDebug) then
    print('TRSMinimap.__find(): '+toStr(result), TDebug.FOOTER);
end;
{$ENDIF}

{*
TRSMinimap._getButton
~~~~~~~~~~~~~~~~~~~~~

.. code-block:: pascal

    function TRSMinimap._getButton(button: integer): _TRSMMButton;

Returns the bounds, center, and radius of the minimap button in _TRSMMButton.

.. note::

    - by Olly
    - Last Updated: 08 August 2013 by Olly

Example:

.. code-block:: pascal

    button := minimap._getButton(MM_BUTTON_COMPASS);
*}
function TRSMinimap._getButton(button: integer): _TRSMMButton;
begin
  case button of
    MM_BUTTON_COMPASS:
      with result do
      begin
        bounds := [self.x + 6, self.y + 5, self.x + 40, self.y + 39];
        center := bounds.getMiddle();
        radius := 16;
      end;

    MM_BUTTON_RUN:
      with result do
      begin
        bounds := [self.x+self.w -40, self.y + 5, self.x+self.w - 6, self.y + 40];
        center := bounds.getMiddle();
        radius := 16;
      end;

    MM_BUTTON_LODESTONE:
      with result do
      begin
        bounds := [self.x + 10, self.y+self.h -37, self.x + 37, self.y+self.h-11];
        center := bounds.getMiddle();
        radius := 13;
      end;

    MM_BUTTON_MAP:
      with result do
      begin
        bounds := [self.x+self.w-35, self.y+self.h-36, self.x+self.w-11, self.y+self.h-13];
        center := bounds.getMiddle();
        radius := 12;
      end;
  end;
end;

(*
TRSMinimap.getAngleRadians
~~~~~~~~~~~~~~~~~~~~~~~~~~

.. code-block:: pascal

    function TRSMinimap.getAngleRadians(): extended;

Returns the compass angle in radians.

.. note::

    - by Coh3n
    - Last Updated: 23 May 2013 by Coh3n

Example:

.. code-block:: pascal

    ang := minimap.getAngleRadians();
*)
function TRSMinimap.getAngleRadians(): extended;
var
  tpa1, tpa2, tpa, tpaCircle: TPointArray;
  ref: TPoint;
  i, j, hh, hhh, min, d, len: integer;
  btn: _TRSMMButton;
begin
  btn := self._getButton(MM_BUTTON_COMPASS);

  tpaCircle := tpaFromCircle(btn.center.x, btn.center.y, btn.radius);

  // color of the red arrow
  findColorsTolerance(tpa, 1646236, btn.bounds, 60);
  filterPointsDist(tpa, btn.radius-3, btn.radius, btn.center.x, btn.center.y);

  len := length(tpa);

  if (len < 1) then
  begin
    print('TRSMinimap.getAngleRadians(): Didn''t find enough of the red arrow color', TDebug.SUB);
    exit;
  end;

  hhh := high(tpaCircle);
  min := 500;

  // get the reference point on the circle (point closest to the north arrow)
  for i := 0 to (len - 1) do
    for j := 0 to hhh do
    begin
      d := distance(tpa[i].x, tpa[i].y, tpaCircle[j].x, tpaCircle[j].y);

      if (d < min) then
      begin
        min := d;
        ref := tpaCircle[j];
      end;
    end;

  // calculate angle based on the endpoint (ref) of the north arrow and the compass's midpoint
  result := arcTan2(ref.y - btn.center.y, ref.x - btn.center.x) + radians(90);

  // to correct -ve answers for angles between 270 and 360
  if (result < 0) then
    result := (result + radians(360));
end;

(*
TRSMinimap.getAngleDegrees
~~~~~~~~~~~~~~~~~~~~~~~~~~

.. code-block:: pascal

    function TRSMinimap.getAngleDegrees(): extended;

Returns the compass angle in radians.

.. note::

    - by Wizzup?
    - Last Updated: 23 May 2013 by Coh3n

Example:

.. code-block:: pascal

    ang := minimap.getAngleDegrees();
*)
function TRSMinimap.getAngleDegrees(): extended;
begin
  result := degrees(self.getAngleRadians());
end;

(*
TRSMinimap.setAngle
~~~~~~~~~~~~~~~~~~~

.. code-block:: pascal

    function TRSMinimap.setAngle(angleDegrees: integer): boolean;

Rotates the compass angle to "angleDegrees". Returns true if rotating was
successful.

.. note::

    - by nielsie95 & Nava2
    - Last Updated: 23 May 2013 by Coh3n

Example:

.. code-block:: pascal

    minimap.setAngle(MM_DIRECTION_SOUTH);
*)
function TRSMinimap.setAngle(angleDegrees: integer): boolean;
  // helper function for setCompassAngle to clean up code
  // compares angle and directionDeg to see how far away it is
  function __setCompassAngle_minCheck(angle, directionDeg: extended): extended;
  begin
    result := minE(abs(angle - (directionDeg + 360)), abs((angle + 360) - directionDeg));
    result := minE(abs(angle - directionDeg), result);
  end;
var
  startAngle, angle, directionDeg, i: extended;
  left: boolean;
  mark: Integer;
begin
  result := false;
  startAngle := (self.getAngleDegrees());

  if (startAngle < 0) then
    exit;

  directionDeg := (angleDegrees * 1.0);

  if (__setCompassAngle_minCheck(startAngle, directionDeg) <= 8.0) then
    exit(true);

  left := (round((360 - startAngle) + directionDeg) mod 360 <= round((startAngle + 360) - directionDeg) mod 360);
  keyDown((ord(not left) * 2) + 37);
  wait(15 + random(50));
  mark := getSystemTime();
  i := 0.0;

  repeat
    wait(10);
    angle := self.getAngleDegrees();
    if (((getSystemTime() - mark > 6000)  and (i < 1.0)) or
        ((getSystemTime() - mark > 10000) and (i < 2.0)) or
        ((getSystemTime() - mark > 14000) and (i < 3.0))) then
    begin
      i := i + 1.0;
    end;
  until ((angle < 0) or
         (getSystemTime() - mark > 14000) or
         (__setCompassAngle_minCheck(angle, directionDeg) <= (7.0 + i)));

  if (left) then
    keyUp(VK_LEFT)
  else
    keyUp(VK_RIGHT);

  wait(75 + random(50));

  result := (__setCompassAngle_minCheck(angle, directionDeg) <= (7.0 + i));

  print('minimap.setAngle(): Set the angle @ ' + floatToStr(self.getAngleDegrees()) + 'degrees', TDebug.SUB);
end;

(*
TRSMinimap.clickCompass
~~~~~~~~~~~~~~~~~~~~~~~

.. code-block:: pascal

    procedure TRSMinimap.clickCompass();

Clicks the Runescape compass, resulting in the mainscreen camera angle to be set
to low, and the minimap compass angle set to north.

.. note::

    - by Olly
    - Last Updated: 08 August 2013 by Olly

Example:

.. code-block:: pascal

    minimap.clickCompass();
    mainscreen.setAngle(MS_ANGLE_HIGH);
*)
procedure TRSMinimap.clickCompass();
var
  btn: _TRSMMButton;
  p: TPoint;
begin
  btn := self._getButton(MM_BUTTON_COMPASS);

  p := btn.center;

  mouseCircle(p.x, p.y, btn.radius, MOUSE_MOVE);

  if (random(4) = 2) then
  begin
    fastClick(MOUSE_RIGHT);
    if (not chooseOption.select(['Face North', 'Face', 'ace north', 'orth'], 500)) then
      fastClick(MOUSE_LEFT); // failsafe.
  end else
    fastClick(MOUSE_LEFT);

  wait(150 + random(300));

  print('minimap.clickCompass(): Succesfully clicked compass', TDebug.SUB);
end;

(*
TRSMinimap.isPointOn
~~~~~~~~~~~~~~~~~~~~

.. code-block:: pascal

    function TRSMinimap.isPointOn(p: TPoint): boolean;

Returns true if the point "p" is on the minimap.

.. note::

    - by Olly
    - Last Updated: 23 May 2013 by Olly

Example:

.. code-block:: pascal

    if (minimap.isPointOn(someRandomPoint)) then
      writeln('Point is on the minimap!');
*)
function TRSMinimap.isPointOn(p: TPoint): boolean;
begin
  result := false;

  if pointInBox(p, self.getBounds()) then
    result := (not pointInTPA(p, self._maskTPA));
end;

(*
TRSMinimap.findDTM
~~~~~~~~~~~~~~~~~~

.. code-block:: pascal

    function TRSMinimap.findDTM(dtm: integer; var x, y: integer; tries: integer = 1): boolean;

Attempts to find on the minimap, will search for the dtm +/- 6 degrees of the
current minimap angle. Includes an optional paramter 'tries' how many tries we
will search for the dtm, on default it's set to 1.

.. note::

    - by Olly
    - Last Updated: 15 August 2013 by Olly

Example:

.. code-block:: pascal

    if (minimap.findDTM(dtm, x, y)) then
      writeln('found the dtm');
*)
function TRSMinimap.findDTM(dtm: integer; var x, y: integer; tries: integer = 1): boolean;
var
  i: integer;
  se, ea, a, e: extended;
begin
  result := false;

  a := self.getAngleDegrees();

  se := a - 8.00;
  ea := a + 8.00;

  for i := 0 to tries do
    if findDTMRotatedAlternating(dtm, x, y, self.getBounds(), se, ea, 0.5, e) then
    begin
      result := (self.isPointOn([x, y]));

      if (result) then
      begin
        print('minimap.findDTM(): Found dtm @ angle ' + floatToStr(e), TDebug.SUB);
        exit(true);
      end;
    end else
      wait(100 + random(200));
end;

{*
TRSMinimap._isValidDot
~~~~~~~~~~~~~~~~~~~~~~

.. code-block:: pascal

    function TRSMinimap._isValidDot(dotType: integer): boolean;

Returns true if "dotType" is valid.  Compares to the minimap dot constants.

.. note::

    - by Coh3n
    - Last Updated: 23 May 2013 by Coh3n

Example:

.. code-block:: pascal

    if (not minimap._isValidDot(MM_DOT_NPC)) then
      exit(false);
*}
function TRSMinimap._isValidDot(dotType: integer): boolean;
var
  arr: TIntegerArray;
begin
  arr := [ MM_DOT_NPC, MM_DOT_ITEM, MM_DOT_PLAYER,
           MM_DOT_FRIEND, MM_DOT_TEAM ];

  result := inIntArray(arr, dotType);
end;

(*
TRSMinimap.getDots
~~~~~~~~~~~~~~~~~~

.. code-block:: pascal

    function TRSMinimap.getDots(dotType: integer; searchBox: TBox): TPointArray;

Returns a TPointArray of every instance of "dotType" found on in "searchBox".

.. note::

    - by Nava2 & Sir R. Magician
    - Last Updated: 23 May 2013 by Coh3n

Example:

.. code-block:: pascal

    dots := minimap.getDots(MM_DOT_NPC, minimap.getBounds());
*)
function TRSMinimap.getDots(dotType: integer; searchBox: TBox): TPointArray;
var
  i, c: integer;
  tpa: TPointArray;
begin
  print('TRSMinimap.getDots()', TDebug.HEADER);

  // confirm valid dot type
  if (not self._isValidDot(dotType)) then
  begin
    print('Invalid dot type '+toStr(dotType), TDebug.ERROR);
    print('TRSMinimap.getDots(): '+toStr(result), TDebug.FOOTER);
    exit;
  end;

  freeze();
  findColors(tpa, 65536, searchBox); // the black shadow color of the minimap dots
  self.filterPoints(tpa);

  if (length(tpa) <= 0) then
  begin
    unfreeze();
    print('No minimap dot color found', TDebug.ERROR);
    print('TRSMinimap.getDots(): '+toStr(result), TDebug.FOOTER);
    exit;
  end;

  setLength(result, length(tpa));
  c := 0;

  // gets the difference between the bottom two colors of a dot
  for i := 0 to high(tpa) do
    if (getColor(tpa[i].x - 1, tpa[i].y - 1) - getColor(tpa[i].x, tpa[i].y - 1) = dotType) then
    begin
      result[c] := point(tpa[i].x, tpa[i].y - 2);
      inc(c);
    end;

  unfreeze();
  setLength(result, c);

  print('Found '+toStr(length(result))+' minimap dots (ID: '+toStr(dotType)+')');
  print('TRSMinimap.getDots(): '+toStr(result), TDebug.FOOTER);
end;

(*
TRSMinimap.getColorPercent
~~~~~~~~~~~~~~~~~~~~~~~~~~

.. code-block:: pascal

    function TRSMinimap.getColorPercent(color, tolerance: integer): extended;

Returns the percentage of the minimap occupied by "color".
    * color: The color to look for.
    * tol: The tolerance on "color".

.. note::

    - by Olly
    - Last Updated: 08 August 2013 by Olly

Example:

.. code-block:: pascal

    // will return true of 60% or more of the minimap is black
    if (minimap.getColorPercent(minimap.getBlackBackground(), 0) > 60.0) then
      writeln('more than 60% of the minimap is black');
*)
function TRSMinimap.getColorPercent(color, tolerance: integer): extended;
var
  tpa: TPointArray;
begin
  findColorsTolerance(tpa, color, self.getBounds(), tolerance);
  self.filterPoints(tpa);

  result := (length(tpa) / MM_PIXEL_COUNT * 100);
end;

(*
TRSMinimap.getBlackBackground
~~~~~~~~~~~~~~~~~~~~~~~~~~~~~

.. code-block:: pascal

    function TRSMinimap.getBlackBackground(): integer;

Get's the most common black color that appears on the minimap.  Useful for dungeons
and second+ stories of buildings.

.. note::

    - by ZephyrsFury
    - Last Updated: 23 May 2013 by Coh3n

Example:

.. code-block:: pascal

    blk := minimap.getBlackBackground();
*)
function TRSMinimap.getBlackBackground(): integer;
var
  i, currentCount, max, hi: Integer;
  tpa: TPointArray;
  cols: TIntegerArray;
begin
  result := -1;

  print('TRSMinimap.getBlackBackground()', TDebug.HEADER);

  findColorsTolerance(tpa, clBlack, self.getBounds(), 3, colorSetting(2, 100, 100));
  self.filterPoints(tpa);

  if (length(tpa) < 1) then
  begin
    print('Failed to find any shades of black', TDebug.ERROR);
    print('TRSMinimap.getBlackBackground(): '+toStr(result), TDebug.FOOTER);
    exit();
  end;

  cols := getColors(TPA, true);
  print('Found '+toStr(length(cols))+' shades of black, finding the most common one...');

  hi := high(cols);
  for i := 0 to hi do
  begin
    currentCount := countColor(cols[i], self.getBounds());

    if (countColor(cols[i], self.getBounds()) > max) then
    begin
      result := cols[i];
      max := currentCount;
    end;
  end;

  print('TRSMinimap.getBlackBackground(): '+toStr(result), TDebug.FOOTER);
end;

(*
TRSMinimap.filterPoints
~~~~~~~~~~~~~~~~~~~~~~~

.. code-block:: pascal

    procedure TRSMinimap.filterPoints(var tpa: TPointArray);

Filters all the points in the tpa that are not on the minimap (the actual map area)

.. note::

    - by Olly
    - Last Updated: 23 May 2013 by Olly

Example:

.. code-block:: pascal

    minimap.filterPoints(tpa);
*)
procedure TRSMinimap.filterPoints(var tpa: TPointArray);
var
  res: TPointArray;
begin
  res := clearTPAFromTPA(tpa, self._maskTPA);
  setLength(tpa, 0);

  tpa := res;
end;

(*
TRSMinimap.isFlagPresent
~~~~~~~~~~~~~~~~~~~~~~~~

.. code-block:: pascal

    function TRSMinimap.isFlagPresent(var p: TPoint): boolean;

Returns true if the flag is present on the minimap. Returns it's coordinates in
"p".

.. note::

    - by Home
    - Last Updated: 29 July 2013 by Olly

Example:

.. code-block:: pascal

    if (minimap.isFlagPresent(p)) then
      writeln('Flag is present');
*)
function TRSMinimap.isFlagPresent(var p: TPoint): boolean;
var
  i, bmp, l: integer;
  tpa: TPointArray;
begin
  result := false;
  bmp := bitmapFromClient(self.getBounds());

  findColorsBitmap(bmp, tpa, 65536);

  l := length(tpa);

  if (l < 1) then
  begin
    freeBitmap(bmp);
    exit();
  end;

  for i := 0 to (l-1) do
    if ((fastGetPixel(bmp, tpa[i].x - 1, tpa[i].y - 1) - fastGetPixel(bmp, tpa[i].x, tpa[i].y - 1)) = 6381921) then
    begin
      result := true;
      p.x := tpa[i].x + self.x;
      p.y := tpa[i].y + self.y;
      break;
    end;

  freeBitmap(bmp);
end;

(*
TRSMinimap.isFlagPresent
~~~~~~~~~~~~~~~~~~~~~~~~

.. code-block:: pascal

    function TRSMinimap.isFlagPresent(): boolean; overload;

An overload function.  Returns true if the flag is present on the minimap, has
a optional waitTime parameter.

.. note::

    - by Coh3n
    - Last Updated: 1 August 2013 by Olly

Example:

.. code-block:: pascal

    if (minimap.isFlagPresent(2000)) then
      writeln('Flag is present');
*)
function TRSMinimap.isFlagPresent(waitTime: integer = 0): boolean; overload;
var
  p: TPoint;
  timeOut: integer;
begin
  timeOut := getSystemTime() + waitTime;
  result := false;

  repeat
    result := (self.isFlagPresent(p));

    if (result) then
      exit(true);

    if (waitTime > 0) then
      wait(15 + random(25));

  until (getSystemTime() >= timeOut);
end;

(*
TRSMinimap.getFlagDistance
~~~~~~~~~~~~~~~~~~~~~~~~~~

.. code-block:: pascal

    function TRSMinimap.getFlagDistance(): integer;

Returns the distance from the player (i.e. the center of the minimap) to the flag.
Returns -1 if the flag isn't present.

.. note::

    - by weequ
    - Last Updated: 23 May 2013 by Coh3n

Example:

.. code-block:: pascal

    dist := minimap.getFlagDistance();
*)
function TRSMinimap.getFlagDistance(): integer;
var
  p, c: TPoint;
begin
  result := -1;

  if (self.isFlagPresent(p)) then
  begin
    c := self.getCenterPoint();
    result := distance(c.x, c.y, p.x, p.y);
  end;
end;

(*
TRSMinimap.waitFlag
~~~~~~~~~~~~~~~~~~~

.. code-block:: pascal

    function TRSMinimap.waitFlag(dist: integer = 0): boolean;

Returns true the player is within "dist" of the flag.

.. note::

    - by Nava2
    - Last Updated: 23 May 2013 by Coh3n

Example:

.. code-block:: pascal

    minimap.waitFlag(10);
*)
function TRSMinimap.waitFlag(dist: integer = 0): boolean;
var
  m, t, d1, d2: integer;
  p, c: TPoint;
begin
  result := false;
  m := getSystemTime();
  t := (m + 20000);

  print('TRSMinimap.waitFlag()', TDebug.HEADER);
  print('Waiting until flag distance equals '+toStr(dist)+'...');

  repeat
    if (not self.isFlagPresent(p)) then
    begin
      print('Flag is not present, resulting true');
      result := true;
      break;
    end;

    c := self.getCenterPoint();
    d1 := distance(p.x, p.y, c.x, c.y);

    if (d1 <= dist) then
    begin
      print('Flag distance is less than or equal to '+toStr(dist));
      result := true;
      break;
    end;

    if (d1 > (dist + 12)) then
      wait(450 + random(70))
    else
      wait(50 + random(50));

    if (getColor(6, 56) <> 13092807) then // border of the loading message
      if (getSystemTime() - m > 5000) then
      begin
        if (d1 = d2) then
        begin
          print('RS took too long to load, exiting');
          break;
        end;

        d2 := d1;
        m := getSystemTime();
      end;

    if (SRL_Events[EVENT_ANTIBAN] <> nil) then
      SRL_Events[EVENT_ANTIBAN]();

  until(getSystemTime() > t);

  print('TRSMinimap.waitFlag(): '+toStr(result), TDebug.FOOTER);
end;

(*
TRSMinimap.isPlayerMoving
~~~~~~~~~~~~~~~~~~~~~~~~~

.. code-block:: pascal

    function TRSMinimap.isPlayerMoving(shiftInterval: integer = 500): boolean;

Returns true if the player is moving (i.e. walking or running).

.. note::

    - by marpis
    - Last Updated: 23 May 2013 by Coh3n

Example:

.. code-block:: pascal

    if (minimap.isPlayerMoving()) then
      writeln('Player is moving!');
*)
function TRSMinimap.isPlayerMoving(shiftInterval: integer = 500): boolean;
var
  shiftBox: TBox;
  c: TPoint;
begin
  c := self.getCenterPoint();
  shiftBox.setBounds(c.x - 30, c.y - 30, c.x + 30, c.y + 30);
  result := (getPixelShift(shiftBox, shiftInterval) > 200);
end;

(*
TRSMinimap.waitPlayerMoving
~~~~~~~~~~~~~~~~~~~~~~~~~~~

.. code-block:: pascal

    function TRSMinimap.waitPlayerMoving(waitFlagGone: boolean): boolean;

Waits while the player is moving.  Returns true if the player is not moving.

.. note::

    - by marpis
    - Last Updated: 23 May 2013 by Coh3n

Example:

.. code-block:: pascal

    if (minimap.tpaWalk(5647837, 10, point(minimap.x2, minimap.y1), 10)) then
    begin
      wait(500 + random(500));
      minimap.waitPlayerMoving();
    end;
*)
function TRSMinimap.waitPlayerMoving(shiftInterval: integer = 500): boolean;
var
  t: integer;
begin
  result := false;
  t := (getSystemTime() + 20000);

  print('Waiting while the player is moving...', TDebug.SUB);

  while (getSystemTime() < t) do
  begin
    wait(randomRange(50, 100));

    if (not self.isPlayerMoving(shiftInterval)) then
      exit(true);

    if (SRL_Events[EVENT_ANTIBAN] <> nil) then
      SRL_Events[EVENT_ANTIBAN]();
  end;
end;

(*
TRSMinimap.radialWalk
~~~~~~~~~~~~~~~~~~~~~

.. code-block:: pascal

    function TRSMinimap.radialWalk(theColor, tol, radius, startRadial, endRadial: integer; flagDist: integer = 0): boolean;

Walks the player to the furthest point found within the given parameters.
    * theColor: The color to look for.
    * tol: The tolerance on "theColor".
    * radius: The maximum radius to look for the color. Should be less than MM_RADIUS.
    * startRadial: The degree value to start looking for the color.
    * endRadial: The degree value to stop looking for the color.
    * flagDist: Optional. The minimum flag distance from the player. Default set to 0.

.. note::

    - by nielsie95 & NCDS
    - Last Updated: 23 May 2013 by Coh3n

Example:

.. code-block:: pascal

    minimap.radialWalk(834782, 10, 100, 45, 135, 10);
*)
function TRSMinimap.radialWalk(theColor, tol, radius, startRadial, endRadial: integer; flagDist: integer = 0): boolean;
var
  sd, ed, direction, i: integer;
  linear: boolean;
  tpa: TPointArray;
  c: TPoint;
begin
  result := false;
  print('TRSMinimap.radialWalk()', TDebug.HEADER);

  sd := startRadial;
  ed := endRadial;

  if (sd = ed) then
  begin
    print('Start and end raidal are equal, using linear walk algorithm');
    linear := true;
    direction := sd;

    if (direction < 50) then
      sd := ((direction + 360) - 50)
    else
      sd := (direction - 50);

    ed := (direction + 50);
    sd := trunc(FixD(sd + 0.0));
    ed := trunc(FixD(ed + 0.0));
  end else
    if (sd > ed) then
      swap(sd, ed);

  c := self.getCenterPoint();

  findColorsTolerance(tpa, theColor, self.getBounds(), tol);
  filterPointsPie(tpa, sd, ed, 10, radius, c.x, c.y);

  if (linear) then
    linearSort(tpa, c.x, c.y, direction, false)
  else
    sortCircleWise(tpa, c.x, c.y, startRadial, false, startRadial > endRadial);

  if (length(tpa) > 0) then
  begin
    print('Found '+toStr(length(tpa))+' instances of color '+toStr(theColor));

    for i := 0 to high(tpa) do
    begin
      mouse(tpa[i], MOUSE_LEFT);
      wait(200 + random(100)); // wait for the flag to appear

      if (self.waitFlag(flagDist)) then
      begin
        result := true;
        break;
      end;
    end;

  end else
    print('Failed to find color '+toStr(theColor)+' with tolerance '+toStr(tol), TDebug.ERROR);

  print('TRSMinimap.radialWalk(): '+toStr(result), TDebug.FOOTER);
end;

(*
TRSMinimap.tpaWalk
~~~~~~~~~~~~~~~~~~

.. code-block:: pascal

    function TRSMinimap.tpaWalk(color, tol: integer; sortFrom: TPoint; flagDist: integer; offset: TPoint = point(0, 0)): boolean;

Uses a simple TPA sorting method to walk to a spot on the minimap. Returns true if walked
successfully.

    * color: The color to be found on the minimap.
    * tol: The tolerance on color.
    * sortFrom: The point on the minimap to sort found colors from.
    * flagDist: The minimum flag distance from the player.
    * offset: Optional. The offset coordinates on the point that's clicked.

.. note::

    - by Coh3n
    - Last Updated: 23 May 2013 by Coh3n

Example:

.. code-block:: pascal

    minimap.tpaWalk(288937, 10, point(minimap.x2, minimap.y1), 10);
*)
function TRSMinimap.tpaWalk(color, tol: integer; sortFrom: TPoint; flagDist: integer; offset: TPoint = point(0, 0)): boolean;
var
  i, t: integer;
  tpa: TPointArray;
  p: TPoint;
begin
  result := false;
  print('TRSMinimap.tpaWalk()', TDebug.HEADER);

  if (findColorsTolerance(tpa, color, self.getBounds(), tol)) then
  begin
    self.filterPoints(tpa);

    print('Found color '+toStr(color)+' on minimap');
    sortTPAFrom(tpa, sortFrom);

    for i := 0 to high(tpa) do
    begin
      p := tpa[i];
      incEx(p.x, offset.x);
      incEx(p.y, offset.y);

      if (not self.isPointOn(p)) then
        continue;

      mouse(p.rand(3), MOUSE_LEFT);

      result := self.waitFlag(3000);

      if (result) then
        break();

      wait(15 + random(50));
    end;

  end else
    print('Failed to find color '+toStr(color)+' with tolerance '+toStr(tol)+' on the minimap', TDebug.ERROR);

  print('TRSMinimap.tpaWalk(): '+toStr(result), TDebug.FOOTER);
end;

{*
TRSMinimap._getSymbol
~~~~~~~~~~~~~~~~~~~~~

.. code-block:: pascal

    function TRSMinimap._getSymbol(sym: integer): _TRSSymbol;

Returns a _TRSSymbol of "sym".

.. note::

    - by The SRL Development Team
    - Last Updated: 23 May 2013 by Coh3n

Example:

.. code-block:: pascal

    sym := minimap._getSymbol(MM_SYMBOL_BANK);
*}
function TRSMinimap._getSymbol(sym: integer): _TRSSymbol;
begin
  case sym of
    MM_SYMBOL_BANK:
      with result do
      begin
        name := 'Bank';
        color := 2216175;
        bmp := BitmapFromString(15, 5, 'beNpjYGRgYDwAAxsWun/9NjnbX' +
          '/D9BUUgOR8GILJAlWiKIcogJBAdQAKYiiHqIQiiHpfJyOqRHYNLMa' +
          'ZjEIoBKZB32A==');
      end;

    MM_SYMBOL_OBELISK_MINI:
      with result do
      begin
        name := 'Mini Obelisk';
        bmp := BitmapFromString(15, 5, 'meJxjYGDYjwTO75ymWJUpaO7FKyw' +
          '7f/58ZCkGMEAW0QrM8q3vAapPz/AgqFg2wguoGEhyKfHhVwx0w4NH' +
          'D4AIaL5TQh4Q4VEMcQNQDVA90HAeRStkw4EqAbnwdxs=');
        color := 12566463;
      end;

    MM_SYMBOL_MINING:
      with result do
      begin
        name := 'Mining Site';
        bmp := BitmapFromString(15, 5, 'beNpjYGRgYDyAAXqrfB' +
          'vCddIzMsrKSiMiIiCCQJWYiufk2INUWova2dkD1Xv7ec+fPx+rYrj' +
          'K+WAANBaXYqDK7GDtIAsBiEqgCFAxnI2seEKsNVCluzoPXBauGOpm' +
          'ADVlcCo=');
        color := 5077645;
      end;

    MM_SYMBOL_TRANSPORTATION:
      with result do
      begin
        name := 'Transportation';
        bmp := BitmapFromString(15, 5, 'z78DA33303534347074353' +
          '4B73032219E34763173348592A62E666E66A6C8B20660330D904C' +
          '86A841D6858BC454896C3EA6C9C498899FC465B291A3B193910B3' +
          '124A69910715C269317CEC866229B0C00B3496273');
        color := 2650848;
      end;

    MM_SYMBOL_SHOP_MAGIC:
      with result do
      begin
        name := 'Magic';
        bmp := BitmapFromString(15, 5, 'z78DA95D0510A80300806' +
          'E02B9906B6C77F3AEF7FA4A0066DABC17A1111FD1469A74CC5C46' +
          '0D6C60875CEA17288D63CE08C771D02A09BA5CBA499DC99AD3CFA' +
          'EB72041B97B9D9C83F6F2ECE69C3D71F46F9EE5C979D155AFDBAA' +
          '5BBFF312D915399C927AF756C82');
        color := 1714669;
      end;

    MM_SYMBOL_WATER:
      with result do
      begin
        name := 'Water';
        bmp := BitmapFromString(15, 5, 'beNpjYGRgYDyABFJrHmt' +
          'm/ACi+fPnH0AFQJW4FAMRfsUQlYfPPgSS7Hb30QzHVAxUCVcMRHgUQ2xHVoxs' +
          'OAMAbyOCjQ==');
        color := 16279593;
      end;

    MM_SYMBOL_FURNACE:
      with result do
      begin
        name := 'Furnace';
        bmp := BitmapFromString(15, 5, 'z78DA3334353435B470' +
          '3101423308696A028466E6C6A6A626E66E6E1640062E12A206A2D' +
          'EC90408A1261882CD3424CA6427472320DBCDCDC810C61EFC2653' +
          '3F34882171990C0058F36390');
        color := 3508223;
      end;

    MM_SYMBOL_ANVIL:
      with result do
      begin
        name := 'Anvil';
        bmp := BitmapFromString(15, 5, 'z78DA95CF510AC0300803D02B' +
          'A59DE0F2D9F6FE771A2CFB10CAC4FE04117C443434D8E4C2EA4A8' +
          '7DFCE8B06FB369AF38C025E139B5C7194EA106F73B9D2991C187D' +
          '3773F92F2BE6A91CBFD05CE9FC00C9DB6164');
        color := 4012591;
      end;

    MM_SYMBOL_TREE:
      with result do
      begin
        name := 'Tree';
        bmp := BitmapFromString(15, 5, 'beNpjYGRgYDwABmw+jCx5' +
          'vBDE08sOQZK7GYAkRAFQJX7FcISpGK4eKIumZf78+ZiKsZo/HwyQF' +
          'cPVA8Xd1XmAJLJKkDMAo5RFgw==');
        color := 494860;
      end;

    MM_SYMBOL_FISHING:
      with result do
      begin
        name := 'Fishing Spot';
        bmp := BitmapFromString(15, 5, 'z78DA8DCE410E80300844D12B4D5BA' +
          '9BAA404EE7F2413675343AA6EFE82D217D061682636ACCCADA779' +
          '045B641F117987CDAFB84D2479D67257B28A0EFD90B9C9F9BB3FD' +
          'FF02EC337F347B39977D83F37AFFEA2D76EDEA4543DE870B2922F' +
          'BB6B6878');
        color := 16743189;
      end;

    MM_SYMBOL_COOK:
      with result do
      begin
        name := 'Cook';
        bmp := BitmapFromString(15, 5, 'z78DAA590410AC0200C04BFB41' +
          'B4D5B8F2ACDFF9FD4D25008885EBC0C21EC0E211010EC6CD66EE7' +
          'C1A4F869A9524AD74BB2CF3139233E2782D9BB713F52CE37A1D98' +
          '4A823D7E678A15FAE4CC4EDDDB5B9B258D932BB61C67DF3FACF0F' +
          '3E40632F');
        color := 1194607;
      end;

    MM_SYMBOL_QUEST:
      with result do
      begin
        name := 'Quest';
        bmp := BitmapFromString(15, 5, 'beNpjYGRgYDwAA22Tnkzffim1' +
          '5jEQAdmmPvuB5Pz58yGyQJVwxUBxIAIqg6iHqIQgNMUQ0/AgrCbDXQI0GeIYi' +
          'EuAAFkx3M0Qx8BdAlEJMhkAMoB+aA==');
        color := 14908517;
      end;

    MM_SYMBOL_MILL:
      with result do
      begin
        name := 'Mill';
        bmp := BitmapFromString(15, 5, 'z78DAB58F3B0AC0300C43AF24A' +
          '75D3CD621BEFF9102D52228822C5D1EC69F878C8140CCA8AEE5D8' +
          'DD0BA97C223BED3E5E27C48CBAE7B878ABF54987B5337FB3E995D' +
          '26DF2973F323B33C9A9D26573A47303B52569D1');
        color := 655103;
      end;

    MM_SYMBOL_DUNGEON:
      with result do
      begin
        name := 'Dungeon';
        bmp :=BitmapFromString(8, 9, 'meJw7cAAEFiz4ExDwBYi0tD4wMMSw' +
          '5vwDCs6cORMoApHCKg4URBOHiBAUl3b9CxGHG8LPPx8oDkRg50Clg' +
          'ILp6a+BbEYGhgMwMBMJHEACEKOAJIQLAAEpc48=');
        color := 2698232;
      end;

    MM_SYMBOL_WEAVE:
      with result do
      begin
        name := 'Weave';
        bmp := BitmapFromString(15, 5, 'z78DA33303230343074367472' +
          '73724526CD0C4C0C8CDC1C0D2DDD2C5D8DDD8C4C0CA0E2103644D' +
          'CDCD1CCD4C40CC246D66B0036D300AFC9986622B3293119979B21' +
          'ECC1E966649793EA6600F03E685F');
        color := 926783;
      end;

    MM_SYMBOL_POTTERY:
      with result do
      begin
        name := 'Potter''s Wheel';
        bmp := BitmapFromString(15, 5, 'z78DA8DCE5B0AC0200C44D1' +
          '2D6592691B3F2DD5FD2FA98F08554A410217C9C73102B966673E7' +
          '64617AA094DA16349D4B15E96621EED05C13B5F19F9DEFF178E14' +
          '3F869CE8479A9267FCFEE619992A55100D7F8519CC37562DBDD6F' +
          'AECE76FEEFD55D5A50983FFBCB76A807CE5139EC460AC');
        color := 270148;
      end;

    MM_SYMBOL_WHEEL:
      with result do
      begin
        name := 'Spinning Wheel';
        bmp := BitmapFromString(15, 5, 'beNpjYGRgYDwABtn' +
          '+gvPnz28I1wGygSQaG8gAqoQoDrIQAJIQQbgauMiEWGs0xenWokAE0QVXD0dA' +
          'XciK58MAUAvIVcHaEJMh7kFWDAQQNZgk3D0MAH8HZ/A=');
        color := 2710649;
      end;

    MM_SYMBOL_GUIDE:
      with result do
      begin
        name := 'Guide';
        bmp := BitmapFromString(15, 5, 'z78DA33303400424717470B27' +
          '33086961E168E4EC64E866E264EE0C614349170B0B4B336411143' +
          '56059880906860848C06488995432193F89CB47F84D869A8FE14E' +
          '8869F8CD24C664E2431E533DC44C00EBA66771');
        color := 13345416;
      end;

    MM_SYMBOL_STORE:
      with result do
      begin
        name := 'General Store';
        bmp := BitmapFromString(15, 5, 'z78DA95D0410EC4200' +
          '840D12B2102C25290DEFF486DCA2C4C9A6666363F46E2D308020D' +
          '32D83DA2AA3E6804276633B66B7AB4006E7D5F57E9406E51DD05B' +
          '84D78C8435849DD5970E9EC0629AB13B692ABB5B34F279BCF6F32' +
          '12A15CE3E8B9B7EE3265C52C73EFF0818A6FB2CA085D4FF317598' +
          '484FA9B6C69689FB37FBFF9FEC35D3E01559765AB');
        color := 3176384;
      end;

    MM_SYMBOL_SHOP_SHIELD:
      with result do
      begin
        name := 'Shield Shop';
        bmp := BitmapFromString(15, 5, 'z78DACDCC3112C0200844D12' +
          'B611484920DE4FE47CA8CA63085BDCD9F6DF6511614BE233CEADA' +
          '16ECFC9553204DD36055D92EF56E2AFD99DB038EDF97864927C8C' +
          '339595EFD9D3CCD9DFC02CAE26976');
        color := 9542286;
      end;

    MM_SYMBOL_ALTAR:
      with result do
      begin
        name := 'Altar';
        bmp := BitmapFromString(15, 5, 'z78DA33703574323475767171' +
          '7431B670B574B2A4888498630036D300C96464F3DD880610F58E2' +
          'E4E8E4E501297C9C49B8F69267E37936732B25EFC26131F1AB84C' +
          '06006E357035');
        color := 9542286;
      end;

    MM_SYMBOL_ARROW:
      with result do
      begin
        name := 'Arrow';
        bmp := BitmapFromString(15, 5, 'z78DA33303570333470353437' +
          '3372249E343633B33475829026161646E626C8B20660330D904C8' +
          '6A841D6858BC454896C3EA6C9C498899FC465B2919BB1A5B12931' +
          '24A69910715C269317CEC866229B0C001E5A61CB');
        color := 2782945;
      end;

    MM_SYMBOL_BAR:
      with result do
      begin
        name := 'Bar';
        bmp := BitmapFromString(15, 5, 'z78DAB5CC310EC0200C43D12B41' +
          'E3001D0389EF7FA44ACD82D4952E5F968757B5B4E28EA56B66E33' +
          '685908EEEA4115736FF1523A016BD8113A636079B0877A1BE663D' +
          '24E73E25A7F99F9CE659F96BEEF2031A5D69A8');
        color := 4433385;
      end;

    MM_SYMBOL_UNDERGROUND:
      with result do
      begin
        name := 'Underground';
        bmp := BitmapFromString(15, 5, 'z78DA33303400422743' +
          '272727134CD2D5C2C8D4D01993B47033303630B434B474B2C4A2C' +
          'BC01001E96FB28B9BA3A10516335D5DCC8C4D9D293119D97C62CC' +
          '24D5646412622631260300830265FA');
        color := 1844712;
      end;

    MM_SYMBOL_TANNER:
      with result do
      begin
        name := 'Tanner';
        bmp := BitmapFromString(15, 5, 'z78DA8D904B0EC0200805AF0' +
          '4F85F4ABDFF991AFB162521D26E26462703919898BAAACEAB82B5' +
          'E5C4ABB52289FED316E8699229DBE63ECB8AA7F8D75319843374C' +
          'C594B4FC2C5177003C7FAE0A90CC2C92ACA392E5B3FDED9F22DCB' +
          '47D9FFF30DFAEB6308');
        color := 3363443;
      end;

    MM_SYMBOL_CHURN:
      with result do
      begin
        name := 'Churn';
        bmp := BitmapFromString(15, 5, 'z78DA9590410A00210845AFA4' +
          'A5FE5A564CF73FD240CE40502DDA3C5CE8031F318150D1ACE94C4' +
          '104C7D04365F159253E2C16A5737342B5735F6F6938E960D66430' +
          '9B0D1B5292146ECD92156ABF1F013CD39DBE736D1E05FCF644FFE' +
          '8BAC6A8FAF927AEB5338A958DF905A105631F');
        color := 1720403;
      end;

    MM_SYMBOL_HOUSE:
      with result do
      begin
        name := 'House';
        bmp := BitmapFromString(15, 5, 'z78DA9D90410AC0300804BF6' +
          '41B2DF66863F3FF2715BA978560A0BD0C32E2B228F766123D53BB' +
          '33E5F5A08DC3ECD434550779BBBE9D3D1290C9846FDEC63EC02A8' +
          '13D9B7F5C77AE9AF337B86DE4A5E1E0D7649EABE4F9F601C37765' +
          'F5');
        color := 4740173
      end;

    MM_SYMBOL_SHOP_AXE:
      with result do
      begin
        name := 'Axe Shop';
        bmp := BitmapFromString(15, 5, 'z78DA95D04B0EC3300804D02B91' +
          '0033F6127F72FF23A52A1BA4AA55BA1959483C036202E953A74F7' +
          'EA6BBC35B260C403335377680767CEB92B7293FE59A71BEBE187D' +
          '1136D2C7C583CAC6E0CCCABF7235B9A13A728B34EB2EA1E1F148E' +
          'E8D8655CDECADF7C977D69FC8B1BA0269E2B27DEEDA9B13D63933' +
          'EB356E4B7C6439');
        color := 6841956;
      end;

    MM_SYMBOL_COOK:
      with result do
      begin
        name := 'Cooking Shop';
        bmp := BitmapFromString(15, 5, 'z78DA8DCE410AC0300804C0' +
          '2F194CDCE42896FCFF49856E0F421072D983BA83D2C56485C608E' +
          '4C484236CA341999CBBFA7020A6CEFEDF74339B9CF3463E530A99' +
          '4993ADDCA55C6D6F647E955B959CB757F22754F2F9ED8DBCCCD01' +
          'B137B3CDAB290E76797E60B5A736560');
        color := 7565679
      end;

    MM_SYMBOL_WINDMILL:
      with result do
      begin
        name := 'Windmill';
        bmp := BitmapFromString(15, 5, 'z78DA3330313033B074367' +
          '6367536C745BA0181A11132E968EC68EA8853BD01D84C0324930D' +
          '5C4C8D8C9C217A91D9C48840D8B84CC6741BB22E6412974A885F6' +
          '8E1665C264348882C3289CB6DB848889900AC8467DB');
        color := 1245183;
      end;

    MM_SYMBOL_MINIGAME:
      with result do
      begin
        name := 'Minigame';
        bmp := BitmapFromString(15, 5, 'z78DA8D90410EC0200804B' +
          'FB4AD22E568B1FFFF52132129C6DAF432214626CB22A340342929' +
          '47B68DAE82066E2C0D99323BFBBB0A0E88CD3555AAC32EBA1393D' +
          '99D6E36E7E38FCEC86FF3906D412D09FBB9E4FFCCA113DFED996D' +
          '8E7FAC13E3CAFCD2B3DD1BB34D3DC7B6CD79039CA16371');
        color := 4670928;
      end;

    MM_SYMBOL_TRADER_FUR:
      with result do
      begin
        name := 'Fur Trader';
        bmp := BitmapFromString(15, 5, 'z78DA3330313033B0743' +
          '67636753647262D2C4C8C0D2C31497357A07A0B64D2D1D8D1D4D1' +
          '1C4242F41A80CD34C06132A6F9C49849BCC9B8CCC76526792623B' +
          'B16BF7A52438378F321660200DE126419');
        color := 607112;
      end;

    MM_SYMBOL_SHOP_ARCHERY:
      with result do
      begin
        name := 'Archery';
        bmp := BitmapFromString(15, 5, 'z78DAA5CE490AC0201' +
          '044D12BB5560F71E910EF7FA4403A0B8318846CFEAA78143129A5' +
          '8A2AD5769A9A29172F8385CD9B91253F1BBA4DDA964733A91A07D' +
          '7FEC8A366A702C59D51DB9215140BF77804BCCC2E0D6136E7AE64' +
          '37477FF5F35BBE0049C36545');
        color := 4945565;
      end;

    MM_SYMBOL_SHOP_STAFF:
      with result do
      begin
        name := 'Staff Shop';
        bmp := BitmapFromString(15, 5, 'z78DAA5D03B0AC0300C0' +
          '3D02BD9F1AF198D83EF7FA442BCB6C1B48B26F110020685191412' +
          'D6C9A96A8C96B2089D5CFCA103DB84B65CA60F49CC32FFCBA55D8' +
          'B7DD0D9ECCBFD9DDFE4F3AB6FF20D38E96664');
        color := 4286358;
      end;

    MM_SYMBOL_SHOP_CLOTHES:
      with result do
      begin
        name := 'Clothes Shop';
        bmp := BitmapFromString(15, 5, 'z78DA8DD04B0AC0200' +
          'C45D12D3DF2D13A0CE9FED754681CA4484A267720CF8308C1C072' +
          '76F51925BE2023CAB2A0D66916F09A487236CF66A73AAFE4686C8' +
          'C4D6DE25622AFE4D8E4FDBE55C8D1BE9CF7FF6FFEFC585B3EFFF9' +
          '012BE4618A');
        color := 5935156;
      end;

    MM_SYMBOL_FARMING:
      with result do
      begin
        name := 'Farming Spot';
        bmp := BitmapFromString(15, 5, 'beNpjYGRgYDyAAwRZC' +
          'Lir87iJ8c2fPx/IBarEpRiicj4M4FGMrBIuiKm4rKw0PSMDqBhNJaZiiEoIQl' +
          'MJUgwAOf97Lg==');
        color := 12632256;
      end;

    MM_SYMBOL_APOTHECARY:
      with result do
      begin
        name := 'Apothecary';
        bmp := BitmapFromString(15, 5, 'z78DA9DD0310AC030088' +
          '5E12B69A3A68ED6D6FB1FA9D02C4230942CFF241F0F814040BD39' +
          '7BAFAA8748C46847C2A75B33B6F21E3E13967236B33CBA2767CDD' +
          '5EFE05926C5F3D23DB932B33C7FE6FFE66AED5A7E01E72B65AE');
        color := 16737938;
      end;

    MM_SYMBOL_SHOP_SWORD:
      with result do
      begin
        name := 'Sword Shop';
        bmp := BitmapFromString(15, 5, 'z78DA95D0410AC030080' +
          '4C02FD9C66CE25125FFFF524BBD08A5C520EC41964124269078F3' +
          'EEE33FC5EF918535971A1B0C6000539B761D91D1A4C7A4829CCD1' +
          '06293E5DCFF929BF231CEBAB92B47EE9A956FBC2FAF9859BE0057' +
          'DB6637');
        color := 10067100;
      end;

    MM_SYMBOL_SHOP_PLATEBODY:
      with result do
      begin
        name := 'Platebody Shop';
        bmp := BitmapFromString(15, 5, 'z78DA8DD0410AC02' +
          '00C44D12BA56832761902BDFF910A9DCD8055DCFC850C4FD1BA85' +
          'DDD5CA0B6CF48818F1E042633190A87D55B0CF349167534FD459D' +
          'DBB92596EB2A527DC3DFC4FFE6EE446F7EC4A66CF65DDEFDFAC3D' +
          '97E77F7E014609646B');
        color := 8157816;
      end;

    MM_SYMBOL_SHOP_SCIMITAR:
      with result do
      begin
        name := 'Scimitar Schop';
        bmp := BitmapFromString(15, 5, 'z78DA9DD04D0AC340' +
          '0805E02B8D7FCF71399349EF7FA4A6B8A825109A203C5CE887D8A' +
          '81D356962CA3FD9475FDD96AE581012880405E267A6D1B7CE0277' +
          '61DBAB56CDEC6963A2F14CAE5AA69B0FF76ADE95315CBDA59FBB2' +
          'AEAAAF50367F35A0630711C0AB697B1B9E9678223F3DAACF21B5C' +
          '65625E');
        color := 8752522;
      end;

    MM_SYMBOL_STALL_GEM:
      with result do
      begin
        name := 'Gem Stall';
        bmp := BitmapFromString(15, 5, 'z78DAA58E4B0AC0300844' +
          'AFA4F96719F3B9FF919A640A154A3729836F21FA18629A1196201' +
          '6ECCD772FE0E03AAA057B32F350338DF50B6A03F1932FF34DEDDC' +
          '1BED0433E7900FCD835C76011B89BFCDAFB6AEAEFB504FCC6013F' +
          '6C4DA8C9E306B1653E29C4D6DBE0027B7630B');
        color := 1777896;
      end;

    MM_SYMBOL_STALL_SILK:
      with result do
      begin
        name := 'Silk Stall';
        bmp := BitmapFromString(15, 5, 'z78DA333034004227432' +
          '733276364D2C2C4C0D0D488181253AF81210262CA42484B67030B' +
          '33476248DA996C696869664994C9C48706B299F84D36733630347' +
          '62486849889CB6400B4306127');
        color := 5374340;
      end;

    MM_SYMBOL_SHOP_PLATESKIRT:
      with result do
      begin
        name := 'Plateskirt Shop';
        bmp := BitmapFromString(15, 5, 'z78DA3330340042' +
          '2743273327634CD2D9D8CCC2D9009974323235763282909686966' +
          '696587419182220F126239B4F9EC9B8DC8929423B93315D4E2034' +
          '709843BCC900457662CC');
        color := 12609731;
      end;

    MM_SYMBOL_AGILITY:
      with result do
      begin
        name := 'Agility';
        bmp := BitmapFromString(15, 5, 'beNpjYGRgYDwABkAGEM2fPx' +
          '+NAWHDFRyAAbgssgIIA1Mxsnq4GjyK0czHFMcUmQ8G6I4EAIrAWyc=');
        color := 65536;
      end;

    MM_SYMBOL_TRAINING_DUMMY:
      with result do
      begin
        name := 'Training Dummy';
        bmp := BitmapFromString(15, 5, 'z78DAA5CC5B0AC43' +
          '00805D02D69468DF9BC6DEAFE97D401032384F92845B8888F434C' +
          'DF0210386A6A6B9D3833270E0F5F5B7371D2FD2B93F857FFE4D4A' +
          'AE962D402E738ED1A0768E08D5CE743FA14A49CB9DF3C95CDA4B3' +
          'A6EC1FB73E6BBE974D6572403C74F9AB2F9769DEA32D69B5');
        color := 1586538;
      end;

    MM_SYMBOL_SHOP_FOOD:
      with result do
      begin
        name := 'Food Shop';
        bmp := BitmapFromString(15, 5, 'z78DAA5D0610AC0200806' +
          'D02B559ADA4F37DAFD8F3499C11C6D63B02F900A79882959B28AC' +
          'A825E09908A0893A0B4C25441ED49A0DA2AB3DFFDDF7B467FE64D' +
          'C88594CF13E56651A08C1DD66146F9A82E47532C0DDFE531F92C8' +
          '77A9183F945BED9C66F396EC385D91F321AD29FE41DF6B66191');
        color := 7837098;
      end;

    MM_SYMBOL_SHOP_FISHING:
      with result do
      begin
        name := 'Fishing Shop';
        bmp := BitmapFromString(15, 5, 'z78DA3330340042470B470B' +
          '27134CD2D2C2C4C8C010425A0081A509844456832962608880E49' +
          '9099431773425DE64E2CD4426F19B8C6CA6990950812BAE50C234' +
          '19D9765C6E8698894C62BA193334304D0600DE086263');
        color := 9734280;
      end;

    MM_SYMBOL_JEWELERY:
      with result do
      begin
        name := 'Jewelery';
        bmp := BitmapFromString(15, 5, 'z78DA9D904B0AC0300844A' +
          'F646843E2D24FBCFF911A6217820DB4DD0C32EA43070A28B08088' +
          '6054AB664DB46B07E64276220109A1D7EEFB4CDE85C5840D79E0E' +
          '05223D3D5BBEEFB4CF4DF933333AA5FFE957CFFDB95DB5356CBFF' +
          '479E471FB395F2DCE59FC917FB9B6AAB');
        color := 4829105;
      end;

    MM_SYMBOL_SHOP_CRAFTING:
      with result do
      begin
        name := 'Crafting';
        bmp := BitmapFromString(15, 5, 'z78DA95CEC10AC020' +
          '0C03D05F8AD3D979AC71FFFF4BC27A29C8A45E420EE111240C748' +
          '2648B24BEFDD5B36414149626F793E45D3708CBDEACA98EAA662A' +
          '94DA2C4FE5D5F49A374FE53F73FF642F9B693D627A79020EC868E' +
          'C');
        color := 3159851;
      end;

    MM_SYMBOL_PORTAL:
      with result do
      begin
        name := 'Portal';
        bmp := BitmapFromString(15, 5, 'z78DAA5D04B0AC0300805' +
          'C02B69D2D6B8D47CEE7FA4045CD442ED22457848D0410208AB549' +
          '4942D2F4858DAA9B05A6A4895251DB93FD2DE6DC6E6BD0078D7B7' +
          'A98374A0CFC86761E2173977C052F764DB8DE43F375B46F2DE3F7' +
          'BD3CB13F26764CE');
        color := 15287202;
      end;

    MM_SYMBOL_MAKEOVER_MAGE:
      with result do
      begin
        name := 'Makeover Mage';
        bmp := BitmapFromString(15, 5, 'z78DA333034703170' +
          '7236707676B68490066011571367734B174CD2D2D8CCD5C418993' +
          '4C06182015E9391D5608A209BEC68E0E8EC4882C9C4BB99129391' +
          'DD499EC9F8CDC76526A6C9003E5F6688');
        color := 10340324;
      end;

    MM_SYMBOL_SHOP_MACE:
      with result do
      begin
        name := 'Mace Shop';
        bmp := BitmapFromString(15, 5, 'z78DA9DD14B0A80300C04' +
          'D02B4D4CF3E93226DEFF4A82155404296EB21A1E330484C29AC8C' +
          'CFE7DAD7BB89A38D9A6696EA2A4A511888C4712878909D9521BB3' +
          'A6086368B248C969FE932F7381546BE477ED6DCEC80F135C64DFD' +
          'A8C7CDFFEEE39F39161EE1ADD6893');
        color := 8817273;
      end;

    MM_SYMBOL_HAIR_DRESSER:
      with result do
      begin
        name := 'Hair Dresser';
        bmp := BitmapFromString(15, 5, 'z78DA33303470317072' +
          '36707676B68490066011030C71E2D5E0977534707476C4A206998' +
          'DAC8654B7E1B2059984C84248F27C8D6C3EB269C4BB19531CD91C' +
          '4CF7E37233005E916796');
        color := 13225152;
      end;

    MM_SYMBOL_SHOP_MINING:
      with result do
      begin
        name := 'Mining Shop';
        bmp := BitmapFromString(15, 5, 'z78DA33B03430313074' +
          'B670367672C5241D2D1C8D2DA1A40158258474737473333285909' +
          '8BA9055E232199944360DBFF9C49B8C6926B22F20E21011FC263B' +
          '5998BAC0447099499EC9C498896C022E9301172B6823');
        color := 10396584;
      end;

    MM_SYMBOL_STALL_SILVER:
      with result do
      begin
        name := 'Silver Stall';
        bmp := BitmapFromString(15, 5, 'z78DA958E410AC0400' +
          '803BF14D1823D6E6DF3FF2715EA4510A17B09C198211008347031' +
          'A4AB4169E2E6EA071F06EFF4F5DE5BF89818C8D9ADB4AE13FF0FB' +
          '976FBF2F4F9B370726D90FBB64977C913BFA6D3E61755066363');
        color := 8749956;
      end;

    MM_SYMBOL_STALL_SPICE:
      with result do
      begin
        name := 'Spice Stall';
        bmp := BitmapFromString(15, 5, 'z78DA9DD0C10E80200C' +
          '03D05FEA06883B22D2FFFF2413F140B240D44BD3C3FA0E8340102' +
          'A0E5619D3984CAC714B50B224D1A72B9BEEBDF71BBFC56DC2C96F' +
          'CCB5EFE5A9F9D1F77244609C66B67CE6B6CE0263997EE39FDFCD5' +
          '1BE002BE06493');
        color := 157167;
      end;

    MM_SYMBOL_SHOP_FARMING:
      with result do
      begin
        name := 'Farming Shop';
        bmp := BitmapFromString(15, 5, 'z78DA95CE410E80200' +
          'C44D12B4D5B405C160CF73F92C461D1C498E0E6D374F1280402EB' +
          '68A30B6B559340150D25F5F95ED55392D556735365BBA96B661DE' +
          '7F025E031F192A9D1E75CAA1D52A2CFD2E42FFB7234BFE478FF8E' +
          '9CE7128332E72FEDAF1C2FDF91A319E51BD93562F0');
        color := 1918090;
      end;

    MM_SYMBOL_SLAYER_MASTER:
      with result do
      begin
        name := 'Slayer Master';
        bmp := BitmapFromString(15, 5, 'z78DAA5D04B0AC030' +
          '0804D02B8D89A5CD320D9DFB1FA9BF8D622D8582B810E6210381A' +
          '00EAC1CA2A85461E3F34C1CB366FBCE7634F6533C4C04D9FAEE62' +
          '84ECF22EDB3F9D53B89525CADF7F4E1BB864B77FB411B359C351D' +
          'E019F8C655C');
        color := 7666933;
      end;

    MM_SYMBOL_SLAYER_CONTRACT:
      with result do
      begin
        name := 'Slayer Contract';
        bmp := BitmapFromString(8, 8, 'meJw7cOCAna0dEFlZfUBGWAUh4kBS' +
        'TnUKEMEFgWxkxRApCAkRZ2RgACK4AiAbWRwiBWGgWQrXheweZF0AZ' +
        'Mk/Hw==');
        color := 3816176;
      end;

    MM_SYMBOL_HERBALIST:
      with result do
      begin
        name := 'Herbalist';
        bmp := BitmapFromString(15, 5, 'z78DA7D8E5D0AC0300883' +
          'AFA4FDD33E5AC6EE7FA415C258C0D10A22267E8DA8EC5A253C9CB' +
          'B5EF5166D7D4C89DE6DE9C45C6DF8BB1733FBBB15FD0A1B10B001' +
          '99F9CCC42C5AB77B16DFEF4C86BF370B355C653272428513EA990' +
          'C3FF3393954EEFC2327CFE4CCCFC933136A263F5CC35F29');
        color := 682309
      end;

    MM_SYMBOL_SHOP_CANDLE:
      with result do
      begin
        name := 'Candle Shop';
        bmp := BitmapFromString(15, 5, 'z78DA33303400422723' +
          '470B470B4CD2CDD0C2D5C01042BA9ABB9A9A3A218BE0D26560888' +
          '0B8D4209B8F6CB2A591051040488A4C367035753571317136B134' +
          '8390B8CC1CEA26030022F6653F');
        color := 6022631;
      end;

    MM_SYMBOL_SAWMILL:
      with result do
      begin
        name := 'Sawmill';
        bmp := BitmapFromString(15, 5, 'z78DAB58EB10DC03008045' +
          '70A600C2EFDF1FE33450A299088A53469AEB08FD3D3498D7861C9' +
          '3A2A4D3ABA0FF1E99619EFBB2BBA9B54CA0A157D69C66FED87FFA' +
          '55CD7663FF7C30120F87173EEEFCA266DF2431F0AB6E11D3C770C' +
          'A76EBE00CD48658B');
        color := 8882835;
      end;

    MM_SYMBOL_SHOP_KEBAB:
      with result do
      begin
        name := 'Kebab Shop';
        bmp := BitmapFromString(15, 5, 'beNpj4OBg4Dh37BgQZTtJRDFwZM8' +
          'xhKD/mpo9DAwgEScJiAKgSohioIjEFJBKIAlEQJUQxcjqkRUDVULE' +
          'gSQQzUl2ArKB5N7qKCBj6dKlyIoh4lhJNMWY6iEIZCNYJUgxALQIU' +
          '2Q=');
        color := 7316427;
      end;

    MM_SYMBOL_SHORTCUT:
      with result do
      begin
        name := 'Agility Shortcut';
        bmp := BitmapFromString(15, 5, 'z78DA8D90410AC0300804' +
          'BFA421A1E95137EDFF9F54E8F62088259741161D64C5B4E98573E' +
          '9821B1A206E3EE49F5DAC1F835724F36F7E9D12CCD370DBE40EE7' +
          '9854FE9864330DF993C8ECC9CC66F65039F7FD551B3BDCFFF9018' +
          '756682E');
        color := 5286667
      end;

    MM_SYMBOL_SHOP_HUNTER:
      with result do
      begin
        name := 'Hunter Shop';
        bmp := BitmapFromString(15, 5, 'z78DA95D0510AC3300' +
          '806E02BC558CDEFA309F6FE47DAC08E3942A143F041934FB1517B' +
          '87C78447CD76BA591CCA445015EE5DD641C459F9D4F554C997F56' +
          'FA36FEC3204819E663A77F25CAE633C972F01BC48AAB9FBB9C373' +
          '79DFB6E69C98DDE1E0813FAE1106FCF897564C992A6277F20B925' +
          '96443');
        color := 1261916;
      end;

    MM_SYMBOL_HUNTING:
      with result do
      begin
        name := 'Hunting';
        bmp := BitmapFromString(15, 5, 'z78DA8DCF410A00' +
          '210C03C02FC52D76E9B18AFFFF92B0EB2150025E728876AC78916' +
          '8D3678C55D360F6F89FE919211B9EC267A2C87CB32F6FFD08EC70' +
          'CF6FDDC8D554597F712FF3AC3AE546C96A1FE573B2BC0197F063A' +
          'B');
        color := 10398118
      end;

    MM_SYMBOL_SAND:
      with result do
      begin
        name := 'Sand Source';
        bmp := BitmapFromString(15, 5, 'z78DA8DCF4B0AC0300' +
          '804D02B8DA9F9B84CA4BDFF91526A16820D64330CA20F0481208A' +
          '51B4FA1C4998CBD07EE5D5EFA654B34F9BC75B7C2682BC336D72E' +
          '247B921239137577766ECB629E9BD959D5CC14CCF8F1FBE88A665' +
          '8794BE952DFDFE49DA95972794856206');
        color := 7717352;
      end;

    MM_SYMBOL_SHOP_PET:
      with result do
      begin
        name := 'Pet Shop';
        bmp := BitmapFromString(15, 5, 'beNpj42Nm4zt87GxnbWFhUkh' +
          'skCsQ7dm7CYIgXKB4dUkYUA1QJVwxULyypllFSQMoBUEQLlAcyF68' +
          'bA1ccV1hBlAQKAXkQoxdOL0LyMalGCgLUQYRhOsCOgOI0BQfWt0JQ' +
          'TomBhAEVAnkAo0FGg5SDADYtlua');
        color := 11713980;
      end;

    MM_SYMBOL_OBELISK:
      with result do
      begin
        name := 'Summoning Obelisk';
        bmp := BitmapFromString(15, 5, 'beNpj42Nm4zt87CwE2SVP1' +
          'XaoKeidC0SeUTWfHj4AiixetgYoCCSBKuGKgSKVNc1AZXMO3AOpWf' +
          '8EqBiiEaIFrhioEigCRJPnrAAqBqJjl98BEVAlxFigGmSTIVqAtgM' +
          'VAI0FqgeSEBMwFQNVAo0FigPVgxjrnwB1Obj4IBQDAImMdLM=');
        color := 10325360;
      end;

    MM_SYMBOL_SHOP_SUMMONING:
      with result do
      begin
        name := 'Summoning Shop';
        bmp := BitmapFromString(15, 5, 'meJyzicq0QUKMDAzIyAZVFk3ZAVS' +
          'AVQtQJGrCfCA6gA0gqweyFyxY8OjFi5MPvwLVb9uyEVM9muLJ377C' +
          '1WNqgRgOABDhZzk=');
        color := 9697013;
      end;

    MM_SYMBOL_SPOT_REST:
      with result do
      begin
        name := 'Resting Spot';
        bmp := BitmapFromString(15, 5, 'beNptjUENwDAMAw2lU' +
          'AylUAyljwEZtFryukVd7xHpYisBzF2wjnEdFfjKWCTdtJY9exfJpJ' +
          'u6kKVhAxeNyj76f/ReM5IceVZ9yhPESE1p');
        color := 65536;
      end;

    MM_SYMBOL_RUNECRAFTING:
      with result do
      begin
        name := 'Runecrafting';
        bmp := BitmapFromString(15, 5, 'meJxjZGA4cOBAREpJY3M7U+tPxu3' +
          'fgAjICAmJBCKIOJABVMPIwMAIVgwR5/T8C1QGIZkFvsPVY1UMJOGG' +
          'A7VA1GMq1rawgQgCFQCVwdUD9QLFgbLIilV0teCGABFcPcRwoCxEM' +
          'QBG91kH');
        color := 542972;
      end;

    MM_SYMBOL_LODESTONE:
      with result do
      begin
        name := 'Lodestone';
        bmp := BitmapFromString(7, 7, 'meJzb09k0KSgPgvZ0Ni2qzb0yDyRS' +
        'YhkMQUA2UBCIfv/5DWQ72tkBSQh7D1jvw8cPgVwgCdEFIYEiEARUD' +
        'xfcvXX9y/MHgCTcZCAXyICYCWEDzQQA7QVQBA==');
        color := 13934210;
      end;

    else
      print('Invalid symbol constant: ' + toStr(sym), TDebug.ERROR);
  end;
end;

{*
TRSMinimap._getSymbolColor
~~~~~~~~~~~~~~~~~~~~~~~~~~

.. code-block:: pascal

    function TRSMinimap._getSymbolColor(var p: TPoint; symbol: integer; searchBox: TBox): integer;

Uses the symbols _TRSSymbol record to return the symbol's color in the "searchBox".
Stores it's coordinates in "p".

.. note::

    - by Coh3n
    - Last Updated: 23 May 2013 by Coh3n

Example:

.. code-block:: pascal

    See the beginning of TRSMinimap.findSymbol().
*}
function TRSMinimap._getSymbolColor(var p: TPoint; symbol: integer; searchBox: TBox): integer;
var
  sym: _TRSSymbol;
  c: integer;
  acc: extended;
begin
  result := -1;
  sym := self._getSymbol(symbol);
  print('TRSMinimap._getSymbolColor()', TDebug.HEADER);

  if (sym.name <> '') then
  begin
    print('Loaded symbol: '+sym.name);

    if (findDeformedBitmapToleranceIn(sym.bmp, p.x, p.y, searchBox, 70, 0, true, acc)) then
    begin
      print('Found symbol bitmap '+toStr(symbol));

      if (acc > self.symbolAccuracy) then
        repeat
          c := c + 5;

          // look for the symbol's color in a small box around where the bitmap was found
          if (findColorTolerance(p.x, p.y, sym.color, p.x, p.y, p.x + 15, p.y + 5, c)) then
          begin
            result := getColor(p.x, p.y);

            if (result > 0) then
            begin
              print('Found '+sym.name+' symbol at '+toStr(p));
              print('TRSMinimap._getSymbolColor(): '+toStr(result), TDebug.FOOTER);
              freeBitmap(sym.bmp);
              exit();
            end;
          end;
        until(c > 70); // max tolerance

      end else
        print('Failed to find bitmap symbol '+toStr(symbol), TDebug.ERROR);
  end;

  print('Failed to find '+sym.name+' symbol', TDebug.ERROR);
  print('Report this bug here: http://villavu.com/forum/project.php?projectid=6', TDebug.HINT);
  print('TRSMinimap._getSymbolColor(): '+toStr(result), TDebug.FOOTER);
  freeBitmap(sym.bmp);

  p := point(-1, -1);
end;

(*
TRSMinimap.findSymbol
~~~~~~~~~~~~~~~~~~~~~

.. code-block:: pascal

    function TRSMinimap.findSymbol(var p: TPoint; symbol: integer; searchBox: TBox): boolean;

Returns true if the "symbol" is found in the "searchBox". Stores it's coordinates
in "p".

.. note::

    - by Stupid3ooo
    - Last Updated: 23 May 2013 by Coh3n

Example:

.. code-block:: pascal

    if (minimap.findSymbol(p, MM_SYMBOL_BANK, minimap.getBounds()) then
    begin
      writeln('Found bank symbol');
      mouse(p, MOUSE_LEFT);
      wait(500 + random(500));
      minimap.waitFlag(10);
    end;
*)
function TRSMinimap.findSymbol(var p: TPoint; symbol: integer; searchBox: TBox): boolean;
begin
  result := (self._getSymbolColor(p, symbol, searchBox) > 0);
end;

(*
TRSMinimap.findSymbols
~~~~~~~~~~~~~~~~~~~~~~

.. code-block:: pascal

    function TRSMinimap.findSymbols(var tpa: TPointArray; symbol: integer; searchBox: TBox): boolean;

Returns true if one or more of the "symbol" is found.  Stores each instance's corrdinates
in "tpa".

.. note::

    - by lordsaturn
    - Last Updated: 23 May 2013 by Coh3n

Example:

.. code-block:: pascal

    symbols := minimap.findSymbols(tpa, MM_SYMBOL_FISHING, intToBox(minimap.x1, minimap.cy, minimap.x2, minimap.y2));
*)
function TRSMinimap.findSymbols(var tpa: TPointArray; symbol: integer; searchBox: TBox): boolean;
var
  sym: _TRSSymbol;
  newColor, i, _x, _y, l: integer;
  tmpATPA: T2DPointArray;
  tmpTPA: TPointArray;
  p, _p: TPoint;
  acc: Extended;
begin
  sym := self._getSymbol(symbol);
  newColor := self._getSymbolColor(_p, symbol, searchBox); // autocolor's the symbol's stored color

  if (sym.color > 0) then
  begin
    // finds all instances of the new color and spits them up
    findColorsTolerance(tmpTPA, newColor, searchBox, 0);
    tmpATPA := tmpTPA.toATPA(10);

    setLength(tpa, length(tmpATPA));

    for i := 0 to high(tmpATPA) do
    begin
      p := middleTPA(tmpATPA[i]);

      // if the original found symbol is in the array (skips a findBitmap call)
      if (tmpATPA[i].isInArray(point(_p.x, _p.y))) then
        acc := 1
      else
        // checks for the bitmap in a small box around where the newColor was found
        findDeformedBitmapToleranceIn(sym.bmp, _x, _y, p.x - 15, p.y - 5, p.x + 15, p.y + 5, 70, 0, true, acc);

      if (acc > self.symbolAccuracy) then
      begin
        tpa[l] := p;
        inc(l);
      end;
    end;

    result := (l > 0);
    setLength(tpa, l);

    if (result) then
      print('TRSMinimap.findSymbols(): Found '+sym.name+' symbol '+toStr(length(tpa))+' times', TDebug.SUB);
  end;

  freeBitmap(sym.bmp);
end;

(*
TRSMinimap.findSymbols
~~~~~~~~~~~~~~~~~~~~~~

.. code-block:: pascal

    function TRSMinimap.findSymbols(var tpa: TPointArray; symbols: TIntegerArray; searchBox: TBox): boolean; overload;

Returns true if one of the symbols in "symbols" is found in "searchBox".  Stores
each symbol's coordinates in "tpa".

.. note::

    - by Nava2 & NCDS
    - Last Updated: 23 May 2013 by Coh3n

Example:

.. code-block:: pascal

    symbols := minimap.findSymbols(tpa, [MM_SYMBOL_BANK, MM_SYMBOL_FISHING], minimap.getBounds());
*)
function TRSMinimap.findSymbols(var tpa: TPointArray; symbols: TIntegerArray; searchBox: TBox): boolean; overload;
var
  gTPA: TPointArray;
  i: integer;
begin
  // loops through each symbol, settings the points where each is found
  for i := 0 to high(symbols) do
  begin
    if (self.findSymbols(gTPA, symbols[i], searchBox)) then
      result := true;

    tpa := combineTPA(gTPA, tpa);
  end;

  if (result) then
    print('TRSMinimap.findSymbols(): Found a total of '+toStr(length(tpa))+' symbols', TDebug.SUB);
end;

(*
TRSMinimap.isResting
~~~~~~~~~~~~~~~~~~~~

.. code-block:: pascal

    function TRSMinimap.isResting(): boolean;

Returns true if the player is resting.

.. note::

    - by Olly
    - Last Updated: 08 August 2013 by Olly

Example:

.. code-block:: pascal

    if (minimap.isResting()) then
      writeln('we are resting!');
*)
function TRSMinimap.isResting(): boolean;
var
  tpa: TPointArray;
  button: _TRSMMButton;
begin
  button := self._getButton(MM_BUTTON_RUN);
  result := false;

  // blue color
  if (not findColorsTolerance(tpa, 13345801, button.bounds, 50)) then
    exit();

  filterPointsDist(tpa, 0, button.radius-1, button.center.x, button.center.y);

  result := inRange(length(tpa), 5, 25);
end;

(*
TRSMinimap.getRunEnergy
~~~~~~~~~~~~~~~~~~~~~~~

.. code-block:: pascal

    function TRSMinimap.getRunEnergy(): integer;

Returns the players current run energy.

.. note::

    - by Olly
    - Last Updated: 08 August 2013 by Olly

Example:

.. code-block:: pascal

    if (minimap.isResting()) then
      writeln('we are resting!');
*)
function TRSMinimap.getRunEnergy(): integer;
begin
 // il figure this out soon..
end;

(*
TRSMinimap.isRunEnabled
~~~~~~~~~~~~~~~~~~~~~~~

.. code-block:: pascal

    function TRSMinimap.isRunEnabled(): boolean;

Returns true if the players run is enabled.

.. note::

    - by Olly
    - Last Updated: 08 August 2013 by Olly

Example:

.. code-block:: pascal

    if (minimap.isRunEnabled()) then
      writeln('Our run is enabled!');
*)
function TRSMinimap.isRunEnabled(): boolean;
var
  tpa: TPointArray;
  button: _TRSMMButton;
begin
  button := self._getButton(MM_BUTTON_RUN);
  result := false;

  // green color
  if (not findColorsTolerance(tpa, 2805490, button.bounds, 20)) then
    exit();

  filterPointsDist(tpa, 0, button.radius-1, button.center.x, button.center.y);

  result := (length(tpa) > 5);
end;

(*
TRSMinimap.toggleRun
~~~~~~~~~~~~~~~~~~~~

.. code-block:: pascal

    procedure TRSMinimap.toggleRun(enable: boolean);

Will toggle run on if enable is set to true, else will turn the run off.

.. note::

    - by Olly
    - Last Updated: 08 August 2013 by Olly

Example:

.. code-block:: pascal

    minimap.toggleRun(true);
*)
procedure TRSMinimap.toggleRun(enable: boolean);
var
  button: _TRSMMButton;
  p: TPoint;
begin
  button := self._getButton(MM_BUTTON_RUN);
  p := button.center;

  case enable of
    true:
      if (not self.isRunEnabled()) then
      begin
        mouseCircle(p.x, p.y, button.radius, MOUSE_LEFT);
        print('minimap.toggleRun(): Enabled run', TDebug.SUB);
      end;

    false:
      if (self.isRunEnabled()) then
      begin
        mouseCircle(p.x, p.y, button.radius, MOUSE_LEFT);
        print('minimap.toggleRun(): Disabled run', TDebug.SUB);
      end;
  end;
end;

(*
TRSMinimap.toggleRun
~~~~~~~~~~~~~~~~~~~~

.. code-block:: pascal

    procedure TRSMinimap.toggleRun(minRunPercent: integer); overload;

Overloaded procedure that will toggle the run on if our run is greater than
'minRunPercent'.

.. note::

    - by Olly
    - Last Updated: 08 August 2013 by Olly

Example:

.. code-block:: pascal

    minimap.toggleRun(50);
*)
procedure TRSMinimap.toggleRun(minRunPercent: integer); overload;
begin
  // needs getRunEnergy()
{
  if (not self.isRunEnabled()) then
    if self.getRun() > minRunPercent then
      self.toggleRun(true);
}
end;

(*
TRSMinimap.isLodestoneOpen
~~~~~~~~~~~~~~~~~~~~~~~~~~

.. code-block:: pascal

    function isLodestoneOpen(out bounds: TBox; waitTime: integer = 0): boolean;

Returns true if the lodestone screen is visable, will also return the bounds of
screen, and includes a optional parameter "waitTime".

.. note::

    - by Olly
    - Last Updated: 04 October 2013 by euphemism

Example:

.. code-block:: pascal

    if minimap.isLodestoneOpen(b, 500 + random(100)) then
      writeln('lodestone screen is open');
*)
function TRSMinimap.isLodestoneOpen(out bounds: TBox; waitTime: integer = 0): boolean;
var
  width, height, timeOut, t: integer;
  tpa: TPointArray;
  p: TPoint;
  b: TBox;
const
  LODESTONE_OFFSET: TPoint = [169, 8];
  LODESTONE_WIDTH: integer = 500;
  LODESTONE_HEIGHT: integer = 300;
begin
  result := false;
  timeOut := getSystemTime() + waitTime;
  t := getSystemTime();

  // middle of the screen
  getClientDimensions(width, height);
  p := [width div 2, height div 2];

  repeat
    // find the white text
    if (findColors(tpa, 12378347, p.x-250, p.y-150, p.x+250, p.y+175)) then
    begin
      b := tpa.getBounds();

      // count the blue color in the bounds of the text (real = 1400)
      result := inRange(countColorTolerance(2498582, b, 5), 1380, 1420);

      if (result) then
      begin
        bounds := [b.x1 - LODESTONE_OFFSET.x,
                   b.y1 - LODESTONE_OFFSET.y,
                   b.x1 + (LODESTONE_WIDTH - LODESTONE_OFFSET.x),
                   b.y1 + (LODESTONE_HEIGHT - LODESTONE_OFFSET.y)];

        print('minimap.isLodestoneOpen(): result = ' + boolToStr(result), TDebug.SUB);

        exit();
      end;
    end;

  until (getSystemTime() >= timeOut);
end;

(*
TRSMinimap.lodestoneTeleportTo
~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~

.. code-block:: pascal

    function lodestoneTeleportTo(location: integer): boolean;

Will click the lodestone teleport to "location".

.. note::

    - by Olly
    - Last Updated: 04 October 2013 by euphemism

Example:

.. code-block:: pascal

    minimap.lodeStoneTeleportTo(LOCATION_LUNAR_ISLE);
*)
function TRSMinimap.lodestoneTeleportTo(location: integer): boolean;
var
  tpa: TPointArray;
  button: _TRSMMButton;
  p: TPoint;
  b: TBox;
begin
  result := false;

  // all teleport location middle points (ugly.. meh)
  tpa :=  [[34, 55], [91, 155], [86, 207], [190, 98], [181, 135], [156, 189],
           [150, 235], [137, 274], [242, 121], [210, 157], [243, 155], [212, 236],
           [303, 96], [282, 134], [268, 180], [265, 225], [335, 158], [298, 187],
           [315, 219], [315, 273], [352, 206], [393, 150]];

  button := minimap._getButton(MM_BUTTON_LODESTONE);
  mouseCircle(button.center.x, button.center.y, button.radius, MOUSE_MOVE);

  if (location = (LOCATION_PREVIOUS)) then
  begin
    fastClick(MOUSE_RIGHT);
    result := chooseOption.select(['Previous dest', 'estination', 'evious'], 1.00, 250 + random(100));

    if (result) then
      print('minimap.lodestoneTo(): Succesfully teleported to previous destination', TDebug.SUB)
    else
      print('minimap.lodestoneTo(): Failed teleport to previous destination (chooseOption must have failed)', TDebug.SUB);

    // regardless of the result, we don't need to go any futher
    exit();
  end;

  if (inRange(location, LOCATION_LUNAR_ISLE, LOCATION_CANIFIS)) then
  begin
    if (not isLodeStoneOpen(b)) then
      fastClick(MOUSE_LEFT);

    if (isLodeStoneOpen(b, 4000 + random(500))) then
    begin
      wait(20 + random(500));

      p := tpa[location];
      p.offset([b.x1, b.y1]);
      mouseBox([p.x - 8, p.y - 8, p.x + 8, p.y + 8], MOUSE_LEFT);

      print('minimap.lodestoneTo(): Succesfully clicked teleport[' + intToStr(location) + ']');
      result := true;
    end else
      print('minimap.lodestoneTo(): Lodestone screen never appeared', TDebug.ERROR);
  end else
    print('minimap.lodestoneTo(): The location you entered isn''t a vaild teleport', TDebug.ERROR);
end;

begin
  minimap.__init();
end;

